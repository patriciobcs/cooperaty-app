{"ast":null,"code":"import { useEffect, useReducer } from 'react';\nimport assert from 'assert';\nconst pageLoadTime = new Date();\nconst globalCache = new Map();\n\nclass FetchLoopListener {\n  constructor(cacheKey, fn, refreshInterval, refreshIntervalOnError, callback, cacheNullValues) {\n    this.cacheKey = void 0;\n    this.fn = void 0;\n    this.refreshInterval = void 0;\n    this.refreshIntervalOnError = void 0;\n    this.callback = void 0;\n    this.cacheNullValues = true;\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.refreshInterval = refreshInterval;\n    this.refreshIntervalOnError = refreshIntervalOnError;\n    this.callback = callback;\n    this.cacheNullValues = cacheNullValues;\n  }\n\n}\n\nclass FetchLoopInternal {\n  constructor(cacheKey, fn, cacheNullValues) {\n    this.cacheKey = void 0;\n    this.fn = void 0;\n    this.timeoutId = void 0;\n    this.listeners = void 0;\n    this.errors = void 0;\n    this.cacheNullValues = true;\n\n    this.refresh = async () => {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n\n      if (this.stopped) {\n        return;\n      }\n\n      let errored = false;\n\n      try {\n        const data = await this.fn();\n\n        if (!this.cacheNullValues && data === null) {\n          console.log(`Not caching null value for ${this.cacheKey}`); // cached data has not changed so no need to re-render\n\n          this.errors = 0;\n          return data;\n        } else {\n          globalCache.set(this.cacheKey, data);\n          this.errors = 0;\n          this.notifyListeners();\n          return data;\n        }\n      } catch (error) {\n        ++this.errors;\n        console.warn(error);\n        errored = true;\n      } finally {\n        if (!this.timeoutId && !this.stopped) {\n          let waitTime = this.refreshInterval;\n\n          if (errored && this.refreshIntervalOnError && this.refreshIntervalOnError > 0) {\n            waitTime = this.refreshIntervalOnError;\n          } // Back off on errors.\n\n\n          if (this.errors > 0) {\n            waitTime = Math.min(1000 * 2 ** (this.errors - 1), 60000);\n          } // Don't do any refreshing for the first five seconds, to make way for other things to load.\n\n\n          const timeSincePageLoad = +new Date() - +pageLoadTime;\n\n          if (timeSincePageLoad < 5000) {\n            waitTime += 5000 - timeSincePageLoad / 2;\n          } // Refresh background pages slowly.\n\n\n          if (document.visibilityState === 'hidden') {\n            waitTime = 60000;\n          } else if (!document.hasFocus()) {\n            waitTime *= 1.5;\n          } // Add jitter so we don't send all requests at the same time.\n\n\n          waitTime *= 0.8 + 0.4 * Math.random();\n          this.timeoutId = setTimeout(this.refresh, waitTime);\n        }\n      }\n    };\n\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.timeoutId = null;\n    this.listeners = new Set();\n    this.errors = 0;\n    this.cacheNullValues = cacheNullValues;\n  }\n\n  get refreshInterval() {\n    return Math.min(...[...this.listeners].map(listener => listener.refreshInterval));\n  }\n\n  get refreshIntervalOnError() {\n    const refreshIntervalsOnError = [...this.listeners].map(listener => listener.refreshIntervalOnError).filter(x => x !== null);\n\n    if (refreshIntervalsOnError.length === 0) {\n      return null;\n    }\n\n    return Math.min(...refreshIntervalsOnError);\n  }\n\n  get stopped() {\n    return this.listeners.size === 0;\n  }\n\n  addListener(listener) {\n    const previousRefreshInterval = this.refreshInterval;\n    this.listeners.add(listener);\n\n    if (this.refreshInterval < previousRefreshInterval) {\n      this.refresh();\n    }\n  }\n\n  removeListener(listener) {\n    assert(this.listeners.delete(listener));\n\n    if (this.stopped) {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n    }\n  }\n\n  notifyListeners() {\n    this.listeners.forEach(listener => listener.callback());\n  }\n\n}\n\nclass FetchLoops {\n  constructor() {\n    this.loops = new Map();\n  }\n\n  addListener(listener) {\n    if (!this.loops.has(listener.cacheKey)) {\n      this.loops.set(listener.cacheKey, new FetchLoopInternal(listener.cacheKey, listener.fn, listener.cacheNullValues));\n    }\n\n    this.loops.get(listener.cacheKey).addListener(listener);\n  }\n\n  removeListener(listener) {\n    const loop = this.loops.get(listener.cacheKey);\n    loop.removeListener(listener);\n\n    if (loop.stopped) {\n      this.loops.delete(listener.cacheKey);\n      globalCache.delete(listener.cacheKey);\n    }\n  }\n\n  refresh(cacheKey) {\n    if (this.loops.has(cacheKey)) {\n      this.loops.get(cacheKey).refresh();\n    }\n  }\n\n  refreshAll() {\n    return Promise.all([...this.loops.values()].map(loop => loop.refresh()));\n  }\n\n}\n\nconst globalLoops = new FetchLoops();\nexport function useAsyncData(asyncFn, cacheKey, {\n  refreshInterval = 60000,\n  refreshIntervalOnError = null\n} = {}, cacheNullValues = true) {\n  const [, rerender] = useReducer(i => i + 1, 0);\n  useEffect(() => {\n    if (!cacheKey) {\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      return () => {};\n    }\n\n    const listener = new FetchLoopListener(cacheKey, asyncFn, refreshInterval, refreshIntervalOnError, rerender, cacheNullValues);\n    globalLoops.addListener(listener);\n    return () => globalLoops.removeListener(listener); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey, refreshInterval]);\n\n  if (!cacheKey) {\n    return [null, false];\n  }\n\n  const loaded = globalCache.has(cacheKey);\n  const data = loaded ? globalCache.get(cacheKey) : undefined;\n  return [data, loaded];\n}\nexport function refreshCache(cacheKey, clearCache = false) {\n  if (clearCache) {\n    globalCache.delete(cacheKey);\n  }\n\n  const loop = globalLoops.loops.get(cacheKey);\n\n  if (loop) {\n    loop.refresh();\n\n    if (clearCache) {\n      loop.notifyListeners();\n    }\n  }\n}\nexport function refreshAllCaches() {\n  for (const loop of globalLoops.loops.values()) {\n    loop.refresh();\n  }\n}\nexport function setCache(cacheKey, value, {\n  initializeOnly = false\n} = {}) {\n  if (initializeOnly && globalCache.has(cacheKey)) {\n    return;\n  }\n\n  globalCache.set(cacheKey, value);\n  const loop = globalLoops.loops.get(cacheKey);\n\n  if (loop) {\n    loop.notifyListeners();\n  }\n}\nexport function getCache(cacheKey) {\n  return globalCache.get(cacheKey);\n}","map":{"version":3,"sources":["/mnt/c/Users/Gianni/Desktop/cooperaty-app/src/utils/fetch-loop.tsx"],"names":["useEffect","useReducer","assert","pageLoadTime","Date","globalCache","Map","FetchLoopListener","constructor","cacheKey","fn","refreshInterval","refreshIntervalOnError","callback","cacheNullValues","FetchLoopInternal","timeoutId","listeners","errors","refresh","clearTimeout","stopped","errored","data","console","log","set","notifyListeners","error","warn","waitTime","Math","min","timeSincePageLoad","document","visibilityState","hasFocus","random","setTimeout","Set","map","listener","refreshIntervalsOnError","filter","x","length","size","addListener","previousRefreshInterval","add","removeListener","delete","forEach","FetchLoops","loops","has","get","loop","refreshAll","Promise","all","values","globalLoops","useAsyncData","asyncFn","rerender","i","loaded","undefined","refreshCache","clearCache","refreshAllCaches","setCache","value","initializeOnly","getCache"],"mappings":"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","sourcesContent":["import { useEffect, useReducer } from 'react';\n\nimport assert from 'assert';\n\nconst pageLoadTime = new Date();\n\nconst globalCache: Map<any, any> = new Map();\n\nclass FetchLoopListener<T = any> {\n  cacheKey: any;\n  fn: () => Promise<T>;\n  refreshInterval: number;\n  refreshIntervalOnError: number | null;\n  callback: () => void;\n  cacheNullValues: Boolean = true;\n\n  constructor(\n    cacheKey: any,\n    fn: () => Promise<T>,\n    refreshInterval: number,\n    refreshIntervalOnError: number | null,\n    callback: () => void,\n    cacheNullValues: Boolean,\n  ) {\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.refreshInterval = refreshInterval;\n    this.refreshIntervalOnError = refreshIntervalOnError;\n    this.callback = callback;\n    this.cacheNullValues = cacheNullValues;\n  }\n}\n\nclass FetchLoopInternal<T = any> {\n  cacheKey: any;\n  fn: () => Promise<T>;\n  timeoutId: null | any;\n  listeners: Set<FetchLoopListener<T>>;\n  errors: number;\n  cacheNullValues: Boolean = true;\n\n  constructor(cacheKey: any, fn: () => Promise<T>, cacheNullValues: Boolean) {\n    this.cacheKey = cacheKey;\n    this.fn = fn;\n    this.timeoutId = null;\n    this.listeners = new Set();\n    this.errors = 0;\n    this.cacheNullValues = cacheNullValues;\n  }\n\n  get refreshInterval(): number {\n    return Math.min(\n      ...[...this.listeners].map((listener) => listener.refreshInterval),\n    );\n  }\n\n  get refreshIntervalOnError(): number | null {\n    const refreshIntervalsOnError: number[] = [...this.listeners]\n      .map((listener) => listener.refreshIntervalOnError)\n      .filter((x): x is number => x !== null);\n    if (refreshIntervalsOnError.length === 0) {\n      return null;\n    }\n    return Math.min(...refreshIntervalsOnError);\n  }\n\n  get stopped(): boolean {\n    return this.listeners.size === 0;\n  }\n\n  addListener(listener: FetchLoopListener<T>): void {\n    const previousRefreshInterval = this.refreshInterval;\n    this.listeners.add(listener);\n    if (this.refreshInterval < previousRefreshInterval) {\n      this.refresh();\n    }\n  }\n\n  removeListener(listener: FetchLoopListener<T>): void {\n    assert(this.listeners.delete(listener));\n    if (this.stopped) {\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = null;\n      }\n    }\n  }\n\n  notifyListeners(): void {\n    this.listeners.forEach((listener) => listener.callback());\n  }\n\n  refresh = async () => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n    if (this.stopped) {\n      return;\n    }\n\n    let errored = false;\n    try {\n      const data = await this.fn();\n      if (!this.cacheNullValues && data === null) {\n        console.log(`Not caching null value for ${this.cacheKey}`);\n        // cached data has not changed so no need to re-render\n        this.errors = 0;\n        return data;\n      } else {\n        globalCache.set(this.cacheKey, data);\n        this.errors = 0;\n        this.notifyListeners();\n        return data;\n      }\n    } catch (error) {\n      ++this.errors;\n      console.warn(error);\n      errored = true;\n    } finally {\n      if (!this.timeoutId && !this.stopped) {\n        let waitTime = this.refreshInterval;\n        if (\n          errored &&\n          this.refreshIntervalOnError &&\n          this.refreshIntervalOnError > 0\n        ) {\n          waitTime = this.refreshIntervalOnError;\n        }\n\n        // Back off on errors.\n        if (this.errors > 0) {\n          waitTime = Math.min(1000 * 2 ** (this.errors - 1), 60000);\n        }\n\n        // Don't do any refreshing for the first five seconds, to make way for other things to load.\n        const timeSincePageLoad = +new Date() - +pageLoadTime;\n        if (timeSincePageLoad < 5000) {\n          waitTime += 5000 - timeSincePageLoad / 2;\n        }\n\n        // Refresh background pages slowly.\n        if (document.visibilityState === 'hidden') {\n          waitTime = 60000;\n        } else if (!document.hasFocus()) {\n          waitTime *= 1.5;\n        }\n\n        // Add jitter so we don't send all requests at the same time.\n        waitTime *= 0.8 + 0.4 * Math.random();\n\n        this.timeoutId = setTimeout(this.refresh, waitTime);\n      }\n    }\n  };\n}\n\nclass FetchLoops {\n  loops = new Map();\n\n  addListener<T>(listener: FetchLoopListener<T>) {\n    if (!this.loops.has(listener.cacheKey)) {\n      this.loops.set(\n        listener.cacheKey,\n        new FetchLoopInternal<T>(\n          listener.cacheKey,\n          listener.fn,\n          listener.cacheNullValues,\n        ),\n      );\n    }\n    this.loops.get(listener.cacheKey).addListener(listener);\n  }\n\n  removeListener<T>(listener: FetchLoopListener<T>) {\n    const loop = this.loops.get(listener.cacheKey);\n    loop.removeListener(listener);\n    if (loop.stopped) {\n      this.loops.delete(listener.cacheKey);\n      globalCache.delete(listener.cacheKey);\n    }\n  }\n\n  refresh(cacheKey) {\n    if (this.loops.has(cacheKey)) {\n      this.loops.get(cacheKey).refresh();\n    }\n  }\n\n  refreshAll() {\n    return Promise.all([...this.loops.values()].map((loop) => loop.refresh()));\n  }\n}\nconst globalLoops = new FetchLoops();\n\nexport function useAsyncData<T = any>(\n  asyncFn: () => Promise<T>,\n  cacheKey: any,\n  { refreshInterval = 60000, refreshIntervalOnError = null } = {},\n  cacheNullValues: Boolean = true,\n): [null | undefined | T, boolean] {\n  const [, rerender] = useReducer((i) => i + 1, 0);\n\n  useEffect(() => {\n    if (!cacheKey) {\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      return () => {};\n    }\n    const listener = new FetchLoopListener<T>(\n      cacheKey,\n      asyncFn,\n      refreshInterval,\n      refreshIntervalOnError,\n      rerender,\n      cacheNullValues,\n    );\n    globalLoops.addListener(listener);\n    return () => globalLoops.removeListener(listener);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey, refreshInterval]);\n\n  if (!cacheKey) {\n    return [null, false];\n  }\n\n  const loaded = globalCache.has(cacheKey);\n  const data = loaded ? globalCache.get(cacheKey) : undefined;\n  return [data, loaded];\n}\n\nexport function refreshCache(cacheKey: any, clearCache = false): void {\n  if (clearCache) {\n    globalCache.delete(cacheKey);\n  }\n  const loop = globalLoops.loops.get(cacheKey);\n  if (loop) {\n    loop.refresh();\n    if (clearCache) {\n      loop.notifyListeners();\n    }\n  }\n}\n\nexport function refreshAllCaches(): void {\n  for (const loop of globalLoops.loops.values()) {\n    loop.refresh();\n  }\n}\n\nexport function setCache(\n  cacheKey: any,\n  value: any,\n  { initializeOnly = false } = {},\n): void {\n  if (initializeOnly && globalCache.has(cacheKey)) {\n    return;\n  }\n  globalCache.set(cacheKey, value);\n  const loop = globalLoops.loops.get(cacheKey);\n  if (loop) {\n    loop.notifyListeners();\n  }\n}\n\nexport function getCache(\n  cacheKey: any\n) {\n  return globalCache.get(cacheKey);\n}\n"]},"metadata":{},"sourceType":"module"}