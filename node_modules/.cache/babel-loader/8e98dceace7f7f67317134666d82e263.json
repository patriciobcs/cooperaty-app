{"ast":null,"code":"var _jsxFileName = \"/mnt/c/Users/Gianni/Desktop/cooperaty-app/src/utils/markets.tsx\";\nimport { Market, MARKETS, OpenOrders, Orderbook, TOKEN_MINTS, TokenInstructions } from '@project-serum/serum';\nimport { PublicKey } from '@solana/web3.js';\nimport React, { useContext, useEffect, useState } from 'react';\nimport { divideBnToNumber, floorToDecimal, getTokenMultiplierFromDecimals, sleep, useLocalStorageState } from './utils';\nimport { refreshCache, useAsyncData } from './fetch-loop';\nimport { useAccountData, useAccountInfo, useConnection } from './connection';\nimport { useWallet } from './wallet';\nimport tuple from 'immutable-tuple';\nimport { notify } from './notifications';\nimport BN from 'bn.js';\nimport { getTokenAccountInfo, parseTokenAccountData, useMintInfos } from './tokens';\nimport { WRAPPED_SOL_MINT } from '@project-serum/serum/lib/token-instructions';\nimport BonfidaApi from './bonfidaConnector'; // Used in debugging, should be false in production\n\nconst _IGNORE_DEPRECATED = false;\nexport const USE_MARKETS = _IGNORE_DEPRECATED ? MARKETS.map(m => ({ ...m,\n  deprecated: false\n})) : MARKETS;\nexport function useMarketsList() {\n  return USE_MARKETS.filter(({\n    name,\n    deprecated\n  }) => {\n    var _process$env$REACT_AP;\n\n    return !deprecated && !((_process$env$REACT_AP = process.env.REACT_APP_EXCLUDE_MARKETS) === null || _process$env$REACT_AP === void 0 ? void 0 : _process$env$REACT_AP.includes(name));\n  });\n}\nexport function useAllMarkets() {\n  const connection = useConnection();\n  const {\n    customMarkets\n  } = useCustomMarkets();\n\n  const getAllMarkets = async () => {\n    const markets = await Promise.all(getMarketInfos(customMarkets).map(async marketInfo => {\n      try {\n        const market = await Market.load(connection, marketInfo.address, {}, marketInfo.programId);\n        return {\n          market,\n          marketName: marketInfo.name,\n          programId: marketInfo.programId\n        };\n      } catch (e) {\n        notify({\n          message: 'Error loading all market',\n          description: e.message,\n          type: 'error'\n        });\n        return null;\n      }\n    }));\n    return markets.filter(m => !!m);\n  };\n\n  return useAsyncData(getAllMarkets, tuple('getAllMarkets', customMarkets.length, connection), {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useUnmigratedOpenOrdersAccounts() {\n  var _wallet$publicKey;\n\n  const connection = useConnection();\n  const {\n    wallet\n  } = useWallet();\n\n  async function getUnmigratedOpenOrdersAccounts() {\n    if (!wallet || !connection || !wallet.publicKey) {\n      return [];\n    }\n\n    console.log('refreshing useUnmigratedOpenOrdersAccounts');\n    let deprecatedOpenOrdersAccounts = [];\n    const deprecatedProgramIds = Array.from(new Set(USE_MARKETS.filter(({\n      deprecated\n    }) => deprecated).map(({\n      programId\n    }) => programId.toBase58()))).map(publicKeyStr => new PublicKey(publicKeyStr));\n    let programId;\n\n    for (programId of deprecatedProgramIds) {\n      try {\n        const openOrdersAccounts = await OpenOrders.findForOwner(connection, wallet.publicKey, programId);\n        deprecatedOpenOrdersAccounts = deprecatedOpenOrdersAccounts.concat(openOrdersAccounts.filter(openOrders => openOrders.baseTokenTotal.toNumber() || openOrders.quoteTokenTotal.toNumber()).filter(openOrders => USE_MARKETS.some(market => market.deprecated && market.address.equals(openOrders.market))));\n      } catch (e) {\n        var _programId;\n\n        console.log('Error loading deprecated markets', (_programId = programId) === null || _programId === void 0 ? void 0 : _programId.toBase58(), e.message);\n      }\n    } // Maybe sort\n\n\n    return deprecatedOpenOrdersAccounts;\n  }\n\n  const cacheKey = tuple('getUnmigratedOpenOrdersAccounts', connection, wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58());\n  const [accounts] = useAsyncData(getUnmigratedOpenOrdersAccounts, cacheKey, {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n  return {\n    accounts,\n    refresh: clearCache => refreshCache(cacheKey, clearCache)\n  };\n}\nconst MarketContext = React.createContext(null);\n\nconst _VERY_SLOW_REFRESH_INTERVAL = 5000 * 1000; // For things that don't really change\n\n\nconst _SLOW_REFRESH_INTERVAL = 5 * 1000; // For things that change frequently\n\n\nconst _FAST_REFRESH_INTERVAL = 1000;\nexport const DEFAULT_MARKET = USE_MARKETS.find(({\n  name,\n  deprecated\n}) => name === 'SRM/USDT' && !deprecated);\nexport function getMarketDetails(market, customMarkets) {\n  var _TOKEN_MINTS$find, _TOKEN_MINTS$find2;\n\n  if (!market) {\n    return {};\n  }\n\n  const marketInfos = getMarketInfos(customMarkets);\n  const marketInfo = marketInfos.find(otherMarket => otherMarket.address.equals(market.address));\n  const baseCurrency = (market === null || market === void 0 ? void 0 : market.baseMintAddress) && ((_TOKEN_MINTS$find = TOKEN_MINTS.find(token => token.address.equals(market.baseMintAddress))) === null || _TOKEN_MINTS$find === void 0 ? void 0 : _TOKEN_MINTS$find.name) || (marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.baseLabel) && `${marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.baseLabel}*` || 'UNKNOWN';\n  const quoteCurrency = (market === null || market === void 0 ? void 0 : market.quoteMintAddress) && ((_TOKEN_MINTS$find2 = TOKEN_MINTS.find(token => token.address.equals(market.quoteMintAddress))) === null || _TOKEN_MINTS$find2 === void 0 ? void 0 : _TOKEN_MINTS$find2.name) || (marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.quoteLabel) && `${marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.quoteLabel}*` || 'UNKNOWN';\n  return { ...marketInfo,\n    marketName: marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.name,\n    baseCurrency,\n    quoteCurrency,\n    marketInfo\n  };\n}\nexport function useCustomMarkets() {\n  const [customMarkets, setCustomMarkets] = useLocalStorageState('customMarkets', []);\n  return {\n    customMarkets,\n    setCustomMarkets\n  };\n}\nexport function MarketProvider({\n  marketAddress,\n  setMarketAddress,\n  children\n}) {\n  const {\n    customMarkets,\n    setCustomMarkets\n  } = useCustomMarkets();\n  const address = marketAddress && new PublicKey(marketAddress);\n  const connection = useConnection();\n  const marketInfos = getMarketInfos(customMarkets);\n  const marketInfo = address && marketInfos.find(market => market.address.equals(address)); // Replace existing market with a non-deprecated one on first load\n\n  useEffect(() => {\n    if (marketInfo && marketInfo.deprecated) {\n      console.log('Switching markets from deprecated', marketInfo);\n\n      if (DEFAULT_MARKET) {\n        setMarketAddress(DEFAULT_MARKET.address.toBase58());\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  const [market, setMarket] = useState();\n  useEffect(() => {\n    var _market$_decoded$ownA;\n\n    if (market && marketInfo && ( // @ts-ignore\n    (_market$_decoded$ownA = market._decoded.ownAddress) === null || _market$_decoded$ownA === void 0 ? void 0 : _market$_decoded$ownA.equals(marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.address))) {\n      return;\n    }\n\n    setMarket(null);\n\n    if (!marketInfo || !marketInfo.address) {\n      notify({\n        message: 'Error loading market',\n        description: 'Please select a market from the dropdown',\n        type: 'error'\n      });\n      return;\n    }\n\n    Market.load(connection, marketInfo.address, {}, marketInfo.programId).then(setMarket).catch(e => notify({\n      message: 'Error loading market',\n      description: e.message,\n      type: 'error'\n    })); // eslint-disable-next-line\n  }, [connection, marketInfo]);\n  return /*#__PURE__*/React.createElement(MarketContext.Provider, {\n    value: {\n      market,\n      ...getMarketDetails(market, customMarkets),\n      setMarketAddress,\n      customMarkets,\n      setCustomMarkets\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 257,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function getTradePageUrl(marketAddress) {\n  if (!marketAddress) {\n    const saved = localStorage.getItem('marketAddress');\n\n    if (saved) {\n      marketAddress = JSON.parse(saved);\n    }\n\n    marketAddress = marketAddress || (DEFAULT_MARKET === null || DEFAULT_MARKET === void 0 ? void 0 : DEFAULT_MARKET.address.toBase58()) || '';\n  }\n\n  return `/market/${marketAddress}`;\n}\nexport function useSelectedTokenAccounts() {\n  const [selectedTokenAccounts, setSelectedTokenAccounts] = useLocalStorageState('selectedTokenAccounts', {});\n  return [selectedTokenAccounts, setSelectedTokenAccounts];\n}\nexport function useMarket() {\n  const context = useContext(MarketContext);\n\n  if (!context) {\n    throw new Error('Missing market context');\n  }\n\n  return context;\n}\nexport function useMarkPrice() {\n  const [markPrice, setMarkPrice] = useState(null);\n  const [orderbook] = useOrderbook();\n  const trades = useTrades();\n  useEffect(() => {\n    var _orderbook$bids, _orderbook$asks;\n\n    let bb = (orderbook === null || orderbook === void 0 ? void 0 : (_orderbook$bids = orderbook.bids) === null || _orderbook$bids === void 0 ? void 0 : _orderbook$bids.length) > 0 && Number(orderbook.bids[0][0]);\n    let ba = (orderbook === null || orderbook === void 0 ? void 0 : (_orderbook$asks = orderbook.asks) === null || _orderbook$asks === void 0 ? void 0 : _orderbook$asks.length) > 0 && Number(orderbook.asks[0][0]);\n    let last = trades && trades.length > 0 && trades[0].price;\n    let markPrice = bb && ba ? last ? [bb, ba, last].sort((a, b) => a - b)[1] : (bb + ba) / 2 : null;\n    setMarkPrice(markPrice);\n  }, [orderbook, trades]);\n  return markPrice;\n}\nexport function _useUnfilteredTrades(limit = 10000) {\n  const {\n    market\n  } = useMarket();\n  const connection = useConnection();\n\n  async function getUnfilteredTrades() {\n    if (!market || !connection) {\n      return null;\n    }\n\n    return await market.loadFills(connection, limit);\n  }\n\n  const [trades] = useAsyncData(getUnfilteredTrades, tuple('getUnfilteredTrades', market, connection), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n  return trades; // NOTE: For now, websocket is too expensive since the event queue is large\n  // and updates very frequently\n  // let data = useAccountData(market && market._decoded.eventQueue);\n  // if (!data) {\n  //   return null;\n  // }\n  // const events = decodeEventQueue(data, limit);\n  // return events\n  //   .filter((event) => event.eventFlags.fill && event.nativeQuantityPaid.gtn(0))\n  //   .map(market.parseFillEvent.bind(market));\n}\nexport function useBonfidaTrades() {\n  const {\n    market\n  } = useMarket();\n  const marketAddress = market === null || market === void 0 ? void 0 : market.address.toBase58();\n\n  async function getBonfidaTrades() {\n    if (!marketAddress) {\n      return null;\n    }\n\n    return await BonfidaApi.getRecentTrades(marketAddress);\n  }\n\n  return useAsyncData(getBonfidaTrades, tuple('getBonfidaTrades', marketAddress), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  }, false);\n}\nexport function useOrderbookAccounts() {\n  const {\n    market\n  } = useMarket(); // @ts-ignore\n\n  let bidData = useAccountData(market && market._decoded.bids); // @ts-ignore\n\n  let askData = useAccountData(market && market._decoded.asks);\n  return {\n    bidOrderbook: market && bidData ? Orderbook.decode(market, bidData) : null,\n    askOrderbook: market && askData ? Orderbook.decode(market, askData) : null\n  };\n}\nexport function useOrderbook(depth = 20) {\n  const {\n    bidOrderbook,\n    askOrderbook\n  } = useOrderbookAccounts();\n  const {\n    market\n  } = useMarket();\n  const bids = !bidOrderbook || !market ? [] : bidOrderbook.getL2(depth).map(([price, size]) => [price, size]);\n  const asks = !askOrderbook || !market ? [] : askOrderbook.getL2(depth).map(([price, size]) => [price, size]);\n  return [{\n    bids,\n    asks\n  }, !!bids || !!asks];\n} // Want the balances table to be fast-updating, dont want open orders to flicker\n// TODO: Update to use websocket\n\nexport function useOpenOrdersAccounts(fast = false) {\n  const {\n    market\n  } = useMarket();\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const connection = useConnection();\n\n  async function getOpenOrdersAccounts() {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    if (!market) {\n      return null;\n    }\n\n    return await market.findOpenOrdersAccountsForOwner(connection, wallet.publicKey);\n  }\n\n  return useAsyncData(getOpenOrdersAccounts, tuple('getOpenOrdersAccounts', wallet, market, connected), {\n    refreshInterval: fast ? _FAST_REFRESH_INTERVAL : _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useSelectedOpenOrdersAccount(fast = false) {\n  const [accounts] = useOpenOrdersAccounts(fast);\n\n  if (!accounts) {\n    return null;\n  }\n\n  return accounts[0];\n}\nexport function useTokenAccounts() {\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const connection = useConnection();\n\n  async function getTokenAccounts() {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    return await getTokenAccountInfo(connection, wallet.publicKey);\n  }\n\n  return useAsyncData(getTokenAccounts, tuple('getTokenAccounts', wallet, connected), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function getSelectedTokenAccountForMint(accounts, mint, selectedPubKey) {\n  if (!accounts || !mint) {\n    return null;\n  }\n\n  const filtered = accounts.filter(({\n    effectiveMint,\n    pubkey\n  }) => mint.equals(effectiveMint) && (!selectedPubKey || (typeof selectedPubKey === 'string' ? selectedPubKey : selectedPubKey.toBase58()) === pubkey.toBase58()));\n  return filtered && filtered[0];\n}\nexport function useSelectedQuoteCurrencyAccount() {\n  const [accounts] = useTokenAccounts();\n  const {\n    market\n  } = useMarket();\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\n  const mintAddress = market === null || market === void 0 ? void 0 : market.quoteMintAddress;\n  return getSelectedTokenAccountForMint(accounts, mintAddress, mintAddress && selectedTokenAccounts[mintAddress.toBase58()]);\n}\nexport function useSelectedBaseCurrencyAccount() {\n  const [accounts] = useTokenAccounts();\n  const {\n    market\n  } = useMarket();\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\n  const mintAddress = market === null || market === void 0 ? void 0 : market.baseMintAddress;\n  return getSelectedTokenAccountForMint(accounts, mintAddress, mintAddress && selectedTokenAccounts[mintAddress.toBase58()]);\n} // TODO: Update to use websocket\n\nexport function useSelectedQuoteCurrencyBalances() {\n  const quoteCurrencyAccount = useSelectedQuoteCurrencyAccount();\n  const {\n    market\n  } = useMarket();\n  const [accountInfo, loaded] = useAccountInfo(quoteCurrencyAccount === null || quoteCurrencyAccount === void 0 ? void 0 : quoteCurrencyAccount.pubkey);\n\n  if (!market || !quoteCurrencyAccount || !loaded || !accountInfo) {\n    return null;\n  }\n\n  if (market.quoteMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\n    var _ref;\n\n    return (_ref = (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.lamports) / 1e9) !== null && _ref !== void 0 ? _ref : 0;\n  }\n\n  return market.quoteSplSizeToNumber(new BN(accountInfo.data.slice(64, 72), 10, 'le'));\n} // TODO: Update to use websocket\n\nexport function useSelectedBaseCurrencyBalances() {\n  const baseCurrencyAccount = useSelectedBaseCurrencyAccount();\n  const {\n    market\n  } = useMarket();\n  const [accountInfo, loaded] = useAccountInfo(baseCurrencyAccount === null || baseCurrencyAccount === void 0 ? void 0 : baseCurrencyAccount.pubkey);\n\n  if (!market || !baseCurrencyAccount || !loaded || !accountInfo) {\n    return null;\n  }\n\n  if (market.baseMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\n    var _ref2;\n\n    return (_ref2 = (accountInfo === null || accountInfo === void 0 ? void 0 : accountInfo.lamports) / 1e9) !== null && _ref2 !== void 0 ? _ref2 : 0;\n  }\n\n  return market.baseSplSizeToNumber(new BN(accountInfo.data.slice(64, 72), 10, 'le'));\n}\nexport function useOpenOrders() {\n  const {\n    market,\n    marketName\n  } = useMarket();\n  const openOrdersAccount = useSelectedOpenOrdersAccount();\n  const {\n    bidOrderbook,\n    askOrderbook\n  } = useOrderbookAccounts();\n\n  if (!market || !openOrdersAccount || !bidOrderbook || !askOrderbook) {\n    return null;\n  }\n\n  return market.filterForOpenOrders(bidOrderbook, askOrderbook, [openOrdersAccount]).map(order => ({ ...order,\n    marketName,\n    market\n  }));\n}\nexport function useTrades(limit = 100) {\n  const trades = _useUnfilteredTrades(limit);\n\n  if (!trades) {\n    return null;\n  } // Until partial fills are each given their own fill, use maker fills\n\n\n  return trades.filter(({\n    eventFlags\n  }) => eventFlags.maker).map(trade => ({ ...trade,\n    side: trade.side === 'buy' ? 'sell' : 'buy'\n  }));\n}\nexport function useLocallyStoredFeeDiscountKey() {\n  const [storedFeeDiscountKey, setStoredFeeDiscountKey] = useLocalStorageState(`feeDiscountKey`, undefined);\n  return {\n    storedFeeDiscountKey: storedFeeDiscountKey ? new PublicKey(storedFeeDiscountKey) : undefined,\n    setStoredFeeDiscountKey\n  };\n}\nexport function useFeeDiscountKeys() {\n  const {\n    market\n  } = useMarket();\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const connection = useConnection();\n  const {\n    setStoredFeeDiscountKey\n  } = useLocallyStoredFeeDiscountKey();\n\n  let getFeeDiscountKeys = async () => {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    if (!market) {\n      return null;\n    }\n\n    const feeDiscountKey = await market.findFeeDiscountKeys(connection, wallet.publicKey);\n\n    if (feeDiscountKey) {\n      setStoredFeeDiscountKey(feeDiscountKey[0].pubkey.toBase58());\n    }\n\n    return feeDiscountKey;\n  };\n\n  return useAsyncData(getFeeDiscountKeys, tuple('getFeeDiscountKeys', wallet, market, connected), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useFills(limit = 100) {\n  const {\n    marketName\n  } = useMarket();\n\n  const fills = _useUnfilteredTrades(limit);\n\n  const [openOrdersAccounts] = useOpenOrdersAccounts();\n\n  if (!openOrdersAccounts || openOrdersAccounts.length === 0) {\n    return null;\n  }\n\n  if (!fills) {\n    return null;\n  }\n\n  return fills.filter(fill => openOrdersAccounts.some(openOrdersAccount => fill.openOrders.equals(openOrdersAccount.publicKey))).map(fill => ({ ...fill,\n    marketName\n  }));\n}\nexport function useAllOpenOrdersAccounts() {\n  var _wallet$publicKey2;\n\n  const {\n    wallet,\n    connected\n  } = useWallet();\n  const connection = useConnection();\n  const marketInfos = useMarketInfos();\n  const programIds = [...new Set(marketInfos.map(info => info.programId.toBase58()))].map(stringProgramId => new PublicKey(stringProgramId));\n\n  const getAllOpenOrdersAccounts = async () => {\n    if (!connected || !wallet) {\n      return [];\n    }\n\n    return (await Promise.all(programIds.map(programId => OpenOrders.findForOwner(connection, wallet.publicKey, programId)))).flat();\n  };\n\n  return useAsyncData(getAllOpenOrdersAccounts, tuple('getAllOpenOrdersAccounts', connection, connected, wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey2 = wallet.publicKey) === null || _wallet$publicKey2 === void 0 ? void 0 : _wallet$publicKey2.toBase58(), marketInfos.length, (programIds || []).length), {\n    refreshInterval: _SLOW_REFRESH_INTERVAL\n  });\n}\nexport function useAllOpenOrdersBalances() {\n  const [openOrdersAccounts, loadedOpenOrdersAccounts] = useAllOpenOrdersAccounts();\n  const [mintInfos, mintInfosConnected] = useMintInfos();\n  const [allMarkets] = useAllMarkets();\n\n  if (!loadedOpenOrdersAccounts || !mintInfosConnected) {\n    return {};\n  }\n\n  const marketsByAddress = Object.fromEntries((allMarkets || []).map(m => [m.market.address.toBase58(), m]));\n  const openOrdersBalances = {};\n\n  for (let account of openOrdersAccounts || []) {\n    const marketInfo = marketsByAddress[account.market.toBase58()];\n    const baseMint = marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.market.baseMintAddress.toBase58();\n    const quoteMint = marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.market.quoteMintAddress.toBase58();\n\n    if (!(baseMint in openOrdersBalances)) {\n      openOrdersBalances[baseMint] = [];\n    }\n\n    if (!(quoteMint in openOrdersBalances)) {\n      openOrdersBalances[quoteMint] = [];\n    }\n\n    const baseMintInfo = mintInfos && mintInfos[baseMint];\n    const baseFree = divideBnToNumber(new BN(account.baseTokenFree), getTokenMultiplierFromDecimals((baseMintInfo === null || baseMintInfo === void 0 ? void 0 : baseMintInfo.decimals) || 0));\n    const baseTotal = divideBnToNumber(new BN(account.baseTokenTotal), getTokenMultiplierFromDecimals((baseMintInfo === null || baseMintInfo === void 0 ? void 0 : baseMintInfo.decimals) || 0));\n    const quoteMintInfo = mintInfos && mintInfos[quoteMint];\n    const quoteFree = divideBnToNumber(new BN(account.quoteTokenFree), getTokenMultiplierFromDecimals((quoteMintInfo === null || quoteMintInfo === void 0 ? void 0 : quoteMintInfo.decimals) || 0));\n    const quoteTotal = divideBnToNumber(new BN(account.quoteTokenTotal), getTokenMultiplierFromDecimals((quoteMintInfo === null || quoteMintInfo === void 0 ? void 0 : quoteMintInfo.decimals) || 0));\n    openOrdersBalances[baseMint].push({\n      market: account.market,\n      free: baseFree,\n      total: baseTotal\n    });\n    openOrdersBalances[quoteMint].push({\n      market: account.market,\n      free: quoteFree,\n      total: quoteTotal\n    });\n  }\n\n  return openOrdersBalances;\n}\nexport const useAllOpenOrders = () => {\n  const connection = useConnection();\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const [loaded, setLoaded] = useState(false);\n  const [refresh, setRefresh] = useState(0);\n  const [openOrders, setOpenOrders] = useState(null);\n  const [lastRefresh, setLastRefresh] = useState(0);\n\n  const refreshOpenOrders = () => {\n    if (new Date().getTime() - lastRefresh > 10 * 1000) {\n      setRefresh(prev => prev + 1);\n    } else {\n      console.log('not refreshing');\n    }\n  };\n\n  useEffect(() => {\n    if (connected && wallet) {\n      const getAllOpenOrders = async () => {\n        setLoaded(false);\n        const _openOrders = [];\n\n        const getOpenOrdersForMarket = async marketInfo => {\n          await sleep(1000 * Math.random()); // Try not to hit rate limit\n\n          try {\n            const market = await Market.load(connection, marketInfo.address, undefined, marketInfo.programId);\n            const orders = await market.loadOrdersForOwner(connection, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey, 30000);\n\n            _openOrders.push({\n              orders: orders,\n              marketAddress: marketInfo.address.toBase58()\n            });\n          } catch (e) {\n            console.warn(`Error loading open order ${marketInfo.name} - ${e}`);\n          }\n        };\n\n        await Promise.all(USE_MARKETS.map(m => getOpenOrdersForMarket(m)));\n        setOpenOrders(_openOrders);\n        setLastRefresh(new Date().getTime());\n        setLoaded(true);\n      };\n\n      getAllOpenOrders();\n    }\n  }, [connection, connected, wallet, refresh]);\n  return {\n    openOrders: openOrders,\n    loaded: loaded,\n    refreshOpenOrders: refreshOpenOrders\n  };\n};\nexport function useBalances() {\n  const baseCurrencyBalances = useSelectedBaseCurrencyBalances();\n  const quoteCurrencyBalances = useSelectedQuoteCurrencyBalances();\n  const openOrders = useSelectedOpenOrdersAccount(true);\n  const {\n    baseCurrency,\n    quoteCurrency,\n    market\n  } = useMarket();\n  const baseExists = openOrders && openOrders.baseTokenTotal && openOrders.baseTokenFree;\n  const quoteExists = openOrders && openOrders.quoteTokenTotal && openOrders.quoteTokenFree;\n\n  if (baseCurrency === 'UNKNOWN' || quoteCurrency === 'UNKNOWN' || !baseCurrency || !quoteCurrency) {\n    return [];\n  }\n\n  return [{\n    market,\n    key: `${baseCurrency}${quoteCurrency}${baseCurrency}`,\n    coin: baseCurrency,\n    wallet: baseCurrencyBalances,\n    orders: baseExists && market && openOrders ? market.baseSplSizeToNumber(openOrders.baseTokenTotal.sub(openOrders.baseTokenFree)) : null,\n    openOrders,\n    unsettled: baseExists && market && openOrders ? market.baseSplSizeToNumber(openOrders.baseTokenFree) : null\n  }, {\n    market,\n    key: `${quoteCurrency}${baseCurrency}${quoteCurrency}`,\n    coin: quoteCurrency,\n    wallet: quoteCurrencyBalances,\n    openOrders,\n    orders: quoteExists && market && openOrders ? market.quoteSplSizeToNumber(openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree)) : null,\n    unsettled: quoteExists && market && openOrders ? market.quoteSplSizeToNumber(openOrders.quoteTokenFree) : null\n  }];\n}\nexport function useWalletBalancesForAllMarkets() {\n  const [tokenAccounts] = useTokenAccounts();\n  const {\n    connected\n  } = useWallet();\n  const [mintInfos, mintInfosConnected] = useMintInfos();\n\n  if (!connected || !mintInfosConnected) {\n    return [];\n  }\n\n  let balances = {};\n\n  for (let account of tokenAccounts || []) {\n    if (!account.account) {\n      continue;\n    }\n\n    let parsedAccount;\n\n    if (account.effectiveMint.equals(WRAPPED_SOL_MINT)) {\n      parsedAccount = {\n        mint: WRAPPED_SOL_MINT,\n        owner: account.pubkey,\n        amount: account.account.lamports\n      };\n    } else {\n      parsedAccount = parseTokenAccountData(account.account.data);\n    }\n\n    if (!(parsedAccount.mint.toBase58() in balances)) {\n      balances[parsedAccount.mint.toBase58()] = 0;\n    }\n\n    const mintInfo = mintInfos && mintInfos[parsedAccount.mint.toBase58()];\n    const additionalAmount = divideBnToNumber(new BN(parsedAccount.amount), getTokenMultiplierFromDecimals((mintInfo === null || mintInfo === void 0 ? void 0 : mintInfo.decimals) || 0));\n    balances[parsedAccount.mint.toBase58()] += additionalAmount;\n  }\n\n  return Object.entries(balances).map(([mint, balance]) => {\n    return {\n      mint,\n      balance\n    };\n  });\n}\nexport function useUnmigratedDeprecatedMarkets() {\n  const connection = useConnection();\n  const {\n    accounts\n  } = useUnmigratedOpenOrdersAccounts();\n  const marketsList = accounts && Array.from(new Set(accounts.map(openOrders => openOrders.market)));\n  const deps = marketsList && marketsList.map(m => m.toBase58());\n\n  const useUnmigratedDeprecatedMarketsInner = async () => {\n    if (!marketsList) {\n      return null;\n    }\n\n    const getMarket = async address => {\n      const marketInfo = USE_MARKETS.find(market => market.address.equals(address));\n\n      if (!marketInfo) {\n        console.log('Failed loading market');\n        notify({\n          message: 'Error loading market',\n          type: 'error'\n        });\n        return null;\n      }\n\n      try {\n        console.log('Loading market', marketInfo.name); // NOTE: Should this just be cached by (connection, marketInfo.address, marketInfo.programId)?\n\n        return await Market.load(connection, marketInfo.address, {}, marketInfo.programId);\n      } catch (e) {\n        console.log('Failed loading market', marketInfo.name, e);\n        notify({\n          message: 'Error loading market',\n          description: e.message,\n          type: 'error'\n        });\n        return null;\n      }\n    };\n\n    return (await Promise.all(marketsList.map(getMarket))).filter(x => x);\n  };\n\n  const [markets] = useAsyncData(useUnmigratedDeprecatedMarketsInner, tuple('useUnmigratedDeprecatedMarketsInner', connection, deps && deps.toString()), {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n\n  if (!markets) {\n    return null;\n  }\n\n  return markets.map(market => ({\n    market,\n    openOrdersList: accounts === null || accounts === void 0 ? void 0 : accounts.filter(openOrders => market && openOrders.market.equals(market.address))\n  }));\n}\nexport function useGetOpenOrdersForDeprecatedMarkets() {\n  const {\n    connected,\n    wallet\n  } = useWallet();\n  const {\n    customMarkets\n  } = useCustomMarkets();\n  const connection = useConnection();\n  const marketsAndOrders = useUnmigratedDeprecatedMarkets();\n  const marketsList = marketsAndOrders && marketsAndOrders.map(({\n    market\n  }) => market); // This isn't quite right: open order balances could change\n\n  const deps = marketsList && marketsList.filter(market => !!market).map(market => market.address.toBase58());\n\n  async function getOpenOrdersForDeprecatedMarkets() {\n    if (!connected || !wallet) {\n      return null;\n    }\n\n    if (!marketsList) {\n      return null;\n    }\n\n    console.log('refreshing getOpenOrdersForDeprecatedMarkets');\n\n    const getOrders = async market => {\n      if (!market) {\n        return null;\n      }\n\n      const {\n        marketName\n      } = getMarketDetails(market, customMarkets);\n\n      try {\n        console.log('Fetching open orders for', marketName); // Can do better than this, we have the open orders accounts already\n\n        return (await market.loadOrdersForOwner(connection, wallet.publicKey)).map(order => ({\n          marketName,\n          market,\n          ...order\n        }));\n      } catch (e) {\n        console.log('Failed loading open orders', market.address.toBase58(), e);\n        notify({\n          message: `Error loading open orders for deprecated ${marketName}`,\n          description: e.message,\n          type: 'error'\n        });\n        return null;\n      }\n    };\n\n    return (await Promise.all(marketsList.map(getOrders))).filter(x => !!x).flat();\n  }\n\n  const cacheKey = tuple('getOpenOrdersForDeprecatedMarkets', connected, connection, wallet, deps && deps.toString());\n  const [openOrders, loaded] = useAsyncData(getOpenOrdersForDeprecatedMarkets, cacheKey, {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n  console.log('openOrders', openOrders);\n  return {\n    openOrders,\n    loaded,\n    refreshOpenOrders: () => refreshCache(cacheKey)\n  };\n}\nexport function useBalancesForDeprecatedMarkets() {\n  const markets = useUnmigratedDeprecatedMarkets();\n  const [customMarkets] = useLocalStorageState('customMarkets', []);\n\n  if (!markets) {\n    return null;\n  }\n\n  const openOrderAccountBalances = [];\n  markets.forEach(({\n    market,\n    openOrdersList\n  }) => {\n    const {\n      baseCurrency,\n      quoteCurrency,\n      marketName\n    } = getMarketDetails(market, customMarkets);\n\n    if (!baseCurrency || !quoteCurrency || !market) {\n      return;\n    }\n\n    (openOrdersList || []).forEach(openOrders => {\n      const inOrdersBase = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.baseTokenTotal) && (openOrders === null || openOrders === void 0 ? void 0 : openOrders.baseTokenFree) && market.baseSplSizeToNumber(openOrders.baseTokenTotal.sub(openOrders.baseTokenFree));\n      const inOrdersQuote = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.quoteTokenTotal) && (openOrders === null || openOrders === void 0 ? void 0 : openOrders.quoteTokenFree) && market.baseSplSizeToNumber(openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree));\n      const unsettledBase = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.baseTokenFree) && market.baseSplSizeToNumber(openOrders.baseTokenFree);\n      const unsettledQuote = (openOrders === null || openOrders === void 0 ? void 0 : openOrders.quoteTokenFree) && market.baseSplSizeToNumber(openOrders.quoteTokenFree);\n      openOrderAccountBalances.push({\n        marketName,\n        market,\n        coin: baseCurrency,\n        key: `${marketName}${baseCurrency}`,\n        orders: inOrdersBase,\n        unsettled: unsettledBase,\n        openOrders\n      });\n      openOrderAccountBalances.push({\n        marketName,\n        market,\n        coin: quoteCurrency,\n        key: `${marketName}${quoteCurrency}`,\n        orders: inOrdersQuote,\n        unsettled: unsettledQuote,\n        openOrders\n      });\n    });\n  });\n  return openOrderAccountBalances;\n}\nexport function getMarketInfos(customMarkets) {\n  const customMarketsInfo = customMarkets.map(m => ({ ...m,\n    address: new PublicKey(m.address),\n    programId: new PublicKey(m.programId),\n    deprecated: false\n  }));\n  return [...customMarketsInfo, ...USE_MARKETS];\n}\nexport function useMarketInfos() {\n  const {\n    customMarkets\n  } = useCustomMarkets();\n  return getMarketInfos(customMarkets);\n}\n/**\n * If selling, choose min tick size. If buying choose a price\n * s.t. given the state of the orderbook, the order will spend\n * `cost` cost currency.\n *\n * @param orderbook serum Orderbook object\n * @param cost quantity to spend. Base currency if selling,\n *  quote currency if buying.\n * @param tickSizeDecimals size of price increment of the market\n */\n\nexport function getMarketOrderPrice(orderbook, cost, tickSizeDecimals) {\n  if (orderbook.isBids) {\n    return orderbook.market.tickSize;\n  }\n\n  let spentCost = 0;\n  let price, sizeAtLevel, costAtLevel;\n  const asks = orderbook.getL2(1000);\n\n  for ([price, sizeAtLevel] of asks) {\n    costAtLevel = price * sizeAtLevel;\n\n    if (spentCost + costAtLevel > cost) {\n      break;\n    }\n\n    spentCost += costAtLevel;\n  }\n\n  const sendPrice = Math.min(price * 1.02, asks[0][0] * 1.05);\n  let formattedPrice;\n\n  if (tickSizeDecimals) {\n    formattedPrice = floorToDecimal(sendPrice, tickSizeDecimals);\n  } else {\n    formattedPrice = sendPrice;\n  }\n\n  return formattedPrice;\n}\nexport function getExpectedFillPrice(orderbook, cost, tickSizeDecimals) {\n  let spentCost = 0;\n  let avgPrice = 0;\n  let price, sizeAtLevel, costAtLevel;\n\n  for ([price, sizeAtLevel] of orderbook.getL2(1000)) {\n    costAtLevel = (orderbook.isBids ? 1 : price) * sizeAtLevel;\n\n    if (spentCost + costAtLevel > cost) {\n      avgPrice += (cost - spentCost) * price;\n      spentCost = cost;\n      break;\n    }\n\n    avgPrice += costAtLevel * price;\n    spentCost += costAtLevel;\n  }\n\n  const totalAvgPrice = avgPrice / Math.min(cost, spentCost);\n  let formattedPrice;\n\n  if (tickSizeDecimals) {\n    formattedPrice = floorToDecimal(totalAvgPrice, tickSizeDecimals);\n  } else {\n    formattedPrice = totalAvgPrice;\n  }\n\n  return formattedPrice;\n}\nexport function useCurrentlyAutoSettling() {\n  const [currentlyAutoSettling, setCurrentlyAutosettling] = useState(false);\n  return [currentlyAutoSettling, setCurrentlyAutosettling];\n}","map":{"version":3,"sources":["/mnt/c/Users/Gianni/Desktop/cooperaty-app/src/utils/markets.tsx"],"names":["Market","MARKETS","OpenOrders","Orderbook","TOKEN_MINTS","TokenInstructions","PublicKey","React","useContext","useEffect","useState","divideBnToNumber","floorToDecimal","getTokenMultiplierFromDecimals","sleep","useLocalStorageState","refreshCache","useAsyncData","useAccountData","useAccountInfo","useConnection","useWallet","tuple","notify","BN","getTokenAccountInfo","parseTokenAccountData","useMintInfos","WRAPPED_SOL_MINT","BonfidaApi","_IGNORE_DEPRECATED","USE_MARKETS","map","m","deprecated","useMarketsList","filter","name","process","env","REACT_APP_EXCLUDE_MARKETS","includes","useAllMarkets","connection","customMarkets","useCustomMarkets","getAllMarkets","markets","Promise","all","getMarketInfos","marketInfo","market","load","address","programId","marketName","e","message","description","type","length","refreshInterval","_VERY_SLOW_REFRESH_INTERVAL","useUnmigratedOpenOrdersAccounts","wallet","getUnmigratedOpenOrdersAccounts","publicKey","console","log","deprecatedOpenOrdersAccounts","deprecatedProgramIds","Array","from","Set","toBase58","publicKeyStr","openOrdersAccounts","findForOwner","concat","openOrders","baseTokenTotal","toNumber","quoteTokenTotal","some","equals","cacheKey","accounts","refresh","clearCache","MarketContext","createContext","_SLOW_REFRESH_INTERVAL","_FAST_REFRESH_INTERVAL","DEFAULT_MARKET","find","getMarketDetails","marketInfos","otherMarket","baseCurrency","baseMintAddress","token","baseLabel","quoteCurrency","quoteMintAddress","quoteLabel","setCustomMarkets","MarketProvider","marketAddress","setMarketAddress","children","setMarket","_decoded","ownAddress","then","catch","getTradePageUrl","saved","localStorage","getItem","JSON","parse","useSelectedTokenAccounts","selectedTokenAccounts","setSelectedTokenAccounts","useMarket","context","Error","useMarkPrice","markPrice","setMarkPrice","orderbook","useOrderbook","trades","useTrades","bb","bids","Number","ba","asks","last","price","sort","a","b","_useUnfilteredTrades","limit","getUnfilteredTrades","loadFills","useBonfidaTrades","getBonfidaTrades","getRecentTrades","useOrderbookAccounts","bidData","askData","bidOrderbook","decode","askOrderbook","depth","getL2","size","useOpenOrdersAccounts","fast","connected","getOpenOrdersAccounts","findOpenOrdersAccountsForOwner","useSelectedOpenOrdersAccount","useTokenAccounts","getTokenAccounts","getSelectedTokenAccountForMint","mint","selectedPubKey","filtered","effectiveMint","pubkey","useSelectedQuoteCurrencyAccount","mintAddress","useSelectedBaseCurrencyAccount","useSelectedQuoteCurrencyBalances","quoteCurrencyAccount","accountInfo","loaded","lamports","quoteSplSizeToNumber","data","slice","useSelectedBaseCurrencyBalances","baseCurrencyAccount","baseSplSizeToNumber","useOpenOrders","openOrdersAccount","filterForOpenOrders","order","eventFlags","maker","trade","side","useLocallyStoredFeeDiscountKey","storedFeeDiscountKey","setStoredFeeDiscountKey","undefined","useFeeDiscountKeys","getFeeDiscountKeys","feeDiscountKey","findFeeDiscountKeys","useFills","fills","fill","useAllOpenOrdersAccounts","useMarketInfos","programIds","info","stringProgramId","getAllOpenOrdersAccounts","flat","useAllOpenOrdersBalances","loadedOpenOrdersAccounts","mintInfos","mintInfosConnected","allMarkets","marketsByAddress","Object","fromEntries","openOrdersBalances","account","baseMint","quoteMint","baseMintInfo","baseFree","baseTokenFree","decimals","baseTotal","quoteMintInfo","quoteFree","quoteTokenFree","quoteTotal","push","free","total","useAllOpenOrders","setLoaded","setRefresh","setOpenOrders","lastRefresh","setLastRefresh","refreshOpenOrders","Date","getTime","prev","getAllOpenOrders","_openOrders","getOpenOrdersForMarket","Math","random","orders","loadOrdersForOwner","warn","useBalances","baseCurrencyBalances","quoteCurrencyBalances","baseExists","quoteExists","key","coin","sub","unsettled","useWalletBalancesForAllMarkets","tokenAccounts","balances","parsedAccount","owner","amount","mintInfo","additionalAmount","entries","balance","useUnmigratedDeprecatedMarkets","marketsList","deps","useUnmigratedDeprecatedMarketsInner","getMarket","x","toString","openOrdersList","useGetOpenOrdersForDeprecatedMarkets","marketsAndOrders","getOpenOrdersForDeprecatedMarkets","getOrders","useBalancesForDeprecatedMarkets","openOrderAccountBalances","forEach","inOrdersBase","inOrdersQuote","unsettledBase","unsettledQuote","customMarketsInfo","getMarketOrderPrice","cost","tickSizeDecimals","isBids","tickSize","spentCost","sizeAtLevel","costAtLevel","sendPrice","min","formattedPrice","getExpectedFillPrice","avgPrice","totalAvgPrice","useCurrentlyAutoSettling","currentlyAutoSettling","setCurrentlyAutosettling"],"mappings":"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","sourcesContent":["import {Market, MARKETS, OpenOrders, Orderbook, TOKEN_MINTS, TokenInstructions,} from '@project-serum/serum';\nimport {PublicKey} from '@solana/web3.js';\nimport React, {useContext, useEffect, useState} from 'react';\nimport {divideBnToNumber, floorToDecimal, getTokenMultiplierFromDecimals, sleep, useLocalStorageState,} from './utils';\nimport {refreshCache, useAsyncData} from './fetch-loop';\nimport {useAccountData, useAccountInfo, useConnection} from './connection';\nimport {useWallet} from './wallet';\nimport tuple from 'immutable-tuple';\nimport {notify} from './notifications';\nimport BN from 'bn.js';\nimport {getTokenAccountInfo, parseTokenAccountData, useMintInfos,} from './tokens';\nimport {\n  Balances,\n  CustomMarketInfo,\n  DeprecatedOpenOrdersBalances,\n  FullMarketInfo,\n  MarketContextValues,\n  MarketInfo,\n  OrderWithMarketAndMarketName,\n  SelectedTokenAccounts,\n  TokenAccount,\n} from './types';\nimport {WRAPPED_SOL_MINT} from '@project-serum/serum/lib/token-instructions';\nimport {Order} from '@project-serum/serum/lib/market';\nimport BonfidaApi from './bonfidaConnector';\n\n// Used in debugging, should be false in production\nconst _IGNORE_DEPRECATED = false;\n\nexport const USE_MARKETS: MarketInfo[] = _IGNORE_DEPRECATED\n  ? MARKETS.map((m) => ({ ...m, deprecated: false }))\n  : MARKETS;\n\nexport function useMarketsList() {\n  return USE_MARKETS.filter(({ name, deprecated }) => !deprecated && !process.env.REACT_APP_EXCLUDE_MARKETS?.includes(name));\n}\n\nexport function useAllMarkets() {\n  const connection = useConnection();\n  const { customMarkets } = useCustomMarkets();\n\n  const getAllMarkets = async () => {\n    const markets: Array<{\n      market: Market;\n      marketName: string;\n      programId: PublicKey;\n    } | null> = await Promise.all(\n      getMarketInfos(customMarkets).map(async (marketInfo) => {\n        try {\n          const market = await Market.load(\n            connection,\n            marketInfo.address,\n            {},\n            marketInfo.programId,\n          );\n          return {\n            market,\n            marketName: marketInfo.name,\n            programId: marketInfo.programId,\n          };\n        } catch (e) {\n          notify({\n            message: 'Error loading all market',\n            description: e.message,\n            type: 'error',\n          });\n          return null;\n        }\n      }),\n    );\n    return markets.filter(\n      (m): m is { market: Market; marketName: string; programId: PublicKey } =>\n        !!m,\n    );\n  };\n  return useAsyncData(\n    getAllMarkets,\n    tuple('getAllMarkets', customMarkets.length, connection),\n    { refreshInterval: _VERY_SLOW_REFRESH_INTERVAL },\n  );\n}\n\nexport function useUnmigratedOpenOrdersAccounts() {\n  const connection = useConnection();\n  const { wallet } = useWallet();\n\n  async function getUnmigratedOpenOrdersAccounts(): Promise<OpenOrders[]> {\n    if (!wallet || !connection || !wallet.publicKey) {\n      return [];\n    }\n    console.log('refreshing useUnmigratedOpenOrdersAccounts');\n    let deprecatedOpenOrdersAccounts: OpenOrders[] = [];\n    const deprecatedProgramIds = Array.from(\n      new Set(\n        USE_MARKETS.filter(\n          ({ deprecated }) => deprecated,\n        ).map(({ programId }) => programId.toBase58()),\n      ),\n    ).map((publicKeyStr) => new PublicKey(publicKeyStr));\n    let programId: PublicKey;\n    for (programId of deprecatedProgramIds) {\n      try {\n        const openOrdersAccounts = await OpenOrders.findForOwner(\n          connection,\n          wallet.publicKey,\n          programId,\n        );\n        deprecatedOpenOrdersAccounts = deprecatedOpenOrdersAccounts.concat(\n          openOrdersAccounts\n            .filter(\n              (openOrders) =>\n                openOrders.baseTokenTotal.toNumber() ||\n                openOrders.quoteTokenTotal.toNumber(),\n            )\n            .filter((openOrders) =>\n              USE_MARKETS.some(\n                (market) =>\n                  market.deprecated && market.address.equals(openOrders.market),\n              ),\n            ),\n        );\n      } catch (e) {\n        console.log(\n          'Error loading deprecated markets',\n          programId?.toBase58(),\n          e.message,\n        );\n      }\n    }\n    // Maybe sort\n    return deprecatedOpenOrdersAccounts;\n  }\n\n  const cacheKey = tuple(\n    'getUnmigratedOpenOrdersAccounts',\n    connection,\n    wallet?.publicKey?.toBase58(),\n  );\n  const [accounts] = useAsyncData(getUnmigratedOpenOrdersAccounts, cacheKey, {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL,\n  });\n\n  return {\n    accounts,\n    refresh: (clearCache: boolean) => refreshCache(cacheKey, clearCache),\n  };\n}\n\nconst MarketContext: React.Context<null | MarketContextValues> = React.createContext<null | MarketContextValues>(\n  null,\n);\n\nconst _VERY_SLOW_REFRESH_INTERVAL = 5000 * 1000;\n\n// For things that don't really change\nconst _SLOW_REFRESH_INTERVAL = 5 * 1000;\n\n// For things that change frequently\nconst _FAST_REFRESH_INTERVAL = 1000;\n\nexport const DEFAULT_MARKET = USE_MARKETS.find(\n  ({ name, deprecated }) => name === 'SRM/USDT' && !deprecated,\n);\n\nexport function getMarketDetails(\n  market: Market | undefined | null,\n  customMarkets: CustomMarketInfo[],\n): FullMarketInfo {\n  if (!market) {\n    return {};\n  }\n  const marketInfos = getMarketInfos(customMarkets);\n  const marketInfo = marketInfos.find((otherMarket) =>\n    otherMarket.address.equals(market.address),\n  );\n  const baseCurrency =\n    (market?.baseMintAddress &&\n      TOKEN_MINTS.find((token) => token.address.equals(market.baseMintAddress))\n        ?.name) ||\n    (marketInfo?.baseLabel && `${marketInfo?.baseLabel}*`) ||\n    'UNKNOWN';\n  const quoteCurrency =\n    (market?.quoteMintAddress &&\n      TOKEN_MINTS.find((token) => token.address.equals(market.quoteMintAddress))\n        ?.name) ||\n    (marketInfo?.quoteLabel && `${marketInfo?.quoteLabel}*`) ||\n    'UNKNOWN';\n\n  return {\n    ...marketInfo,\n    marketName: marketInfo?.name,\n    baseCurrency,\n    quoteCurrency,\n    marketInfo,\n  };\n}\n\nexport function useCustomMarkets() {\n  const [customMarkets, setCustomMarkets] = useLocalStorageState<\n    CustomMarketInfo[]\n  >('customMarkets', []);\n  return { customMarkets, setCustomMarkets };\n}\n\nexport function MarketProvider({ marketAddress, setMarketAddress, children }) {\n  const { customMarkets, setCustomMarkets } = useCustomMarkets();\n\n  const address = marketAddress && new PublicKey(marketAddress);\n  const connection = useConnection();\n  const marketInfos = getMarketInfos(customMarkets);\n  const marketInfo =\n    address && marketInfos.find((market) => market.address.equals(address));\n\n  // Replace existing market with a non-deprecated one on first load\n  useEffect(() => {\n    if (marketInfo && marketInfo.deprecated) {\n      console.log('Switching markets from deprecated', marketInfo);\n      if (DEFAULT_MARKET) {\n        setMarketAddress(DEFAULT_MARKET.address.toBase58());\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const [market, setMarket] = useState<Market | null>();\n  useEffect(() => {\n    if (\n      market &&\n      marketInfo &&\n      // @ts-ignore\n      market._decoded.ownAddress?.equals(marketInfo?.address)\n    ) {\n      return;\n    }\n    setMarket(null);\n    if (!marketInfo || !marketInfo.address) {\n      notify({\n        message: 'Error loading market',\n        description: 'Please select a market from the dropdown',\n        type: 'error',\n      });\n      return;\n    }\n    Market.load(connection, marketInfo.address, {}, marketInfo.programId)\n      .then(setMarket)\n      .catch((e) =>\n        notify({\n          message: 'Error loading market',\n          description: e.message,\n          type: 'error',\n        }),\n      );\n    // eslint-disable-next-line\n  }, [connection, marketInfo]);\n\n  return (\n    <MarketContext.Provider\n      value={{\n        market,\n        ...getMarketDetails(market, customMarkets),\n        setMarketAddress,\n        customMarkets,\n        setCustomMarkets,\n      }}\n    >\n      {children}\n    </MarketContext.Provider>\n  );\n}\n\nexport function getTradePageUrl(marketAddress?: string) {\n  if (!marketAddress) {\n    const saved = localStorage.getItem('marketAddress');\n    if (saved) {\n      marketAddress = JSON.parse(saved);\n    }\n    marketAddress = marketAddress || DEFAULT_MARKET?.address.toBase58() || '';\n  }\n  return `/market/${marketAddress}`;\n}\n\nexport function useSelectedTokenAccounts(): [\n  SelectedTokenAccounts,\n  (newSelectedTokenAccounts: SelectedTokenAccounts) => void,\n] {\n  const [\n    selectedTokenAccounts,\n    setSelectedTokenAccounts,\n  ] = useLocalStorageState<SelectedTokenAccounts>('selectedTokenAccounts', {});\n  return [selectedTokenAccounts, setSelectedTokenAccounts];\n}\n\nexport function useMarket() {\n  const context = useContext(MarketContext);\n  if (!context) {\n    throw new Error('Missing market context');\n  }\n  return context;\n}\n\nexport function useMarkPrice() {\n  const [markPrice, setMarkPrice] = useState<null | number>(null);\n\n  const [orderbook] = useOrderbook();\n  const trades = useTrades();\n\n  useEffect(() => {\n    let bb = orderbook?.bids?.length > 0 && Number(orderbook.bids[0][0]);\n    let ba = orderbook?.asks?.length > 0 && Number(orderbook.asks[0][0]);\n    let last = trades && trades.length > 0 && trades[0].price;\n\n    let markPrice =\n      bb && ba\n        ? last\n          ? [bb, ba, last].sort((a, b) => a - b)[1]\n          : (bb + ba) / 2\n        : null;\n\n    setMarkPrice(markPrice);\n  }, [orderbook, trades]);\n\n  return markPrice;\n}\n\nexport function _useUnfilteredTrades(limit = 10000) {\n  const { market } = useMarket();\n  const connection = useConnection();\n  async function getUnfilteredTrades(): Promise<any[] | null> {\n    if (!market || !connection) {\n      return null;\n    }\n    return await market.loadFills(connection, limit);\n  }\n  const [trades] = useAsyncData(\n    getUnfilteredTrades,\n    tuple('getUnfilteredTrades', market, connection),\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\n  );\n  return trades;\n  // NOTE: For now, websocket is too expensive since the event queue is large\n  // and updates very frequently\n\n  // let data = useAccountData(market && market._decoded.eventQueue);\n  // if (!data) {\n  //   return null;\n  // }\n  // const events = decodeEventQueue(data, limit);\n  // return events\n  //   .filter((event) => event.eventFlags.fill && event.nativeQuantityPaid.gtn(0))\n  //   .map(market.parseFillEvent.bind(market));\n}\n\nexport function useBonfidaTrades() {\n  const { market } = useMarket();\n  const marketAddress = market?.address.toBase58();\n\n  async function getBonfidaTrades() {\n    if (!marketAddress) {\n      return null;\n    }\n    return await BonfidaApi.getRecentTrades(marketAddress);\n  }\n\n  return useAsyncData(\n    getBonfidaTrades,\n    tuple('getBonfidaTrades', marketAddress),\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\n    false,\n  );\n}\n\nexport function useOrderbookAccounts() {\n  const { market } = useMarket();\n  // @ts-ignore\n  let bidData = useAccountData(market && market._decoded.bids);\n  // @ts-ignore\n  let askData = useAccountData(market && market._decoded.asks);\n  return {\n    bidOrderbook: market && bidData ? Orderbook.decode(market, bidData) : null,\n    askOrderbook: market && askData ? Orderbook.decode(market, askData) : null,\n  };\n}\n\nexport function useOrderbook(\n  depth = 20,\n): [{ bids: number[][]; asks: number[][] }, boolean] {\n  const { bidOrderbook, askOrderbook } = useOrderbookAccounts();\n  const { market } = useMarket();\n  const bids =\n    !bidOrderbook || !market\n      ? []\n      : bidOrderbook.getL2(depth).map(([price, size]) => [price, size]);\n  const asks =\n    !askOrderbook || !market\n      ? []\n      : askOrderbook.getL2(depth).map(([price, size]) => [price, size]);\n  return [{ bids, asks }, !!bids || !!asks];\n}\n\n// Want the balances table to be fast-updating, dont want open orders to flicker\n// TODO: Update to use websocket\nexport function useOpenOrdersAccounts(fast = false) {\n  const { market } = useMarket();\n  const { connected, wallet } = useWallet();\n  const connection = useConnection();\n  async function getOpenOrdersAccounts() {\n    if (!connected || !wallet) {\n      return null;\n    }\n    if (!market) {\n      return null;\n    }\n    return await market.findOpenOrdersAccountsForOwner(\n      connection,\n      wallet.publicKey,\n    );\n  }\n  return useAsyncData<OpenOrders[] | null>(\n    getOpenOrdersAccounts,\n    tuple('getOpenOrdersAccounts', wallet, market, connected),\n    { refreshInterval: fast ? _FAST_REFRESH_INTERVAL : _SLOW_REFRESH_INTERVAL },\n  );\n}\n\nexport function useSelectedOpenOrdersAccount(fast = false) {\n  const [accounts] = useOpenOrdersAccounts(fast);\n  if (!accounts) {\n    return null;\n  }\n  return accounts[0];\n}\n\nexport function useTokenAccounts(): [\n  TokenAccount[] | null | undefined,\n  boolean,\n] {\n  const { connected, wallet } = useWallet();\n  const connection = useConnection();\n  async function getTokenAccounts() {\n    if (!connected || !wallet) {\n      return null;\n    }\n    return await getTokenAccountInfo(connection, wallet.publicKey);\n  }\n  return useAsyncData(\n    getTokenAccounts,\n    tuple('getTokenAccounts', wallet, connected),\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\n  );\n}\n\nexport function getSelectedTokenAccountForMint(\n  accounts: TokenAccount[] | undefined | null,\n  mint: PublicKey | undefined,\n  selectedPubKey?: string | PublicKey | null,\n) {\n  if (!accounts || !mint) {\n    return null;\n  }\n  const filtered = accounts.filter(\n    ({ effectiveMint, pubkey }) =>\n      mint.equals(effectiveMint) &&\n      (!selectedPubKey ||\n        (typeof selectedPubKey === 'string'\n          ? selectedPubKey\n          : selectedPubKey.toBase58()) === pubkey.toBase58()),\n  );\n  return filtered && filtered[0];\n}\n\nexport function useSelectedQuoteCurrencyAccount() {\n  const [accounts] = useTokenAccounts();\n  const { market } = useMarket();\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\n  const mintAddress = market?.quoteMintAddress;\n  return getSelectedTokenAccountForMint(\n    accounts,\n    mintAddress,\n    mintAddress && selectedTokenAccounts[mintAddress.toBase58()],\n  );\n}\n\nexport function useSelectedBaseCurrencyAccount() {\n  const [accounts] = useTokenAccounts();\n  const { market } = useMarket();\n  const [selectedTokenAccounts] = useSelectedTokenAccounts();\n  const mintAddress = market?.baseMintAddress;\n  return getSelectedTokenAccountForMint(\n    accounts,\n    mintAddress,\n    mintAddress && selectedTokenAccounts[mintAddress.toBase58()],\n  );\n}\n\n// TODO: Update to use websocket\nexport function useSelectedQuoteCurrencyBalances() {\n  const quoteCurrencyAccount = useSelectedQuoteCurrencyAccount();\n  const { market } = useMarket();\n  const [accountInfo, loaded] = useAccountInfo(quoteCurrencyAccount?.pubkey);\n  if (!market || !quoteCurrencyAccount || !loaded || !accountInfo) {\n    return null;\n  }\n  if (market.quoteMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\n    return accountInfo?.lamports / 1e9 ?? 0;\n  }\n  return market.quoteSplSizeToNumber(\n    new BN(accountInfo.data.slice(64, 72), 10, 'le'),\n  );\n}\n\n// TODO: Update to use websocket\nexport function useSelectedBaseCurrencyBalances() {\n  const baseCurrencyAccount = useSelectedBaseCurrencyAccount();\n  const { market } = useMarket();\n  const [accountInfo, loaded] = useAccountInfo(baseCurrencyAccount?.pubkey);\n  if (!market || !baseCurrencyAccount || !loaded || !accountInfo) {\n    return null;\n  }\n  if (market.baseMintAddress.equals(TokenInstructions.WRAPPED_SOL_MINT)) {\n    return accountInfo?.lamports / 1e9 ?? 0;\n  }\n  return market.baseSplSizeToNumber(\n    new BN(accountInfo.data.slice(64, 72), 10, 'le'),\n  );\n}\n\nexport function useOpenOrders() {\n  const { market, marketName } = useMarket();\n  const openOrdersAccount = useSelectedOpenOrdersAccount();\n  const { bidOrderbook, askOrderbook } = useOrderbookAccounts();\n  if (!market || !openOrdersAccount || !bidOrderbook || !askOrderbook) {\n    return null;\n  }\n  return market\n    .filterForOpenOrders(bidOrderbook, askOrderbook, [openOrdersAccount])\n    .map((order) => ({ ...order, marketName, market }));\n}\n\nexport function useTrades(limit = 100) {\n  const trades = _useUnfilteredTrades(limit);\n  if (!trades) {\n    return null;\n  }\n  // Until partial fills are each given their own fill, use maker fills\n  return trades\n    .filter(({ eventFlags }) => eventFlags.maker)\n    .map((trade) => ({\n      ...trade,\n      side: trade.side === 'buy' ? 'sell' : 'buy',\n    }));\n}\n\nexport function useLocallyStoredFeeDiscountKey(): {\n  storedFeeDiscountKey: PublicKey | undefined;\n  setStoredFeeDiscountKey: (key: string) => void;\n} {\n  const [\n    storedFeeDiscountKey,\n    setStoredFeeDiscountKey,\n  ] = useLocalStorageState<string>(`feeDiscountKey`, undefined);\n  return {\n    storedFeeDiscountKey: storedFeeDiscountKey\n      ? new PublicKey(storedFeeDiscountKey)\n      : undefined,\n    setStoredFeeDiscountKey,\n  };\n}\n\nexport function useFeeDiscountKeys(): [\n  (\n    | {\n        pubkey: PublicKey;\n        feeTier: number;\n        balance: number;\n        mint: PublicKey;\n      }[]\n    | null\n    | undefined\n  ),\n  boolean,\n] {\n  const { market } = useMarket();\n  const { connected, wallet } = useWallet();\n  const connection = useConnection();\n  const { setStoredFeeDiscountKey } = useLocallyStoredFeeDiscountKey();\n  let getFeeDiscountKeys = async () => {\n    if (!connected || !wallet) {\n      return null;\n    }\n    if (!market) {\n      return null;\n    }\n    const feeDiscountKey = await market.findFeeDiscountKeys(\n      connection,\n      wallet.publicKey,\n    );\n    if (feeDiscountKey) {\n      setStoredFeeDiscountKey(feeDiscountKey[0].pubkey.toBase58());\n    }\n    return feeDiscountKey;\n  };\n  return useAsyncData(\n    getFeeDiscountKeys,\n    tuple('getFeeDiscountKeys', wallet, market, connected),\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\n  );\n}\n\nexport function useFills(limit = 100) {\n  const { marketName } = useMarket();\n  const fills = _useUnfilteredTrades(limit);\n  const [openOrdersAccounts] = useOpenOrdersAccounts();\n  if (!openOrdersAccounts || openOrdersAccounts.length === 0) {\n    return null;\n  }\n  if (!fills) {\n    return null;\n  }\n  return fills\n    .filter((fill) =>\n      openOrdersAccounts.some((openOrdersAccount) =>\n        fill.openOrders.equals(openOrdersAccount.publicKey),\n      ),\n    )\n    .map((fill) => ({ ...fill, marketName }));\n}\n\nexport function useAllOpenOrdersAccounts() {\n  const { wallet, connected } = useWallet();\n  const connection = useConnection();\n  const marketInfos = useMarketInfos();\n  const programIds = [\n    ...new Set(marketInfos.map((info) => info.programId.toBase58())),\n  ].map((stringProgramId) => new PublicKey(stringProgramId));\n\n  const getAllOpenOrdersAccounts = async () => {\n    if (!connected || !wallet) {\n      return [];\n    }\n    return (\n      await Promise.all(\n        programIds.map((programId) =>\n          OpenOrders.findForOwner(connection, wallet.publicKey, programId),\n        ),\n      )\n    ).flat();\n  };\n  return useAsyncData(\n    getAllOpenOrdersAccounts,\n    tuple(\n      'getAllOpenOrdersAccounts',\n      connection,\n      connected,\n      wallet?.publicKey?.toBase58(),\n      marketInfos.length,\n      (programIds || []).length,\n    ),\n    { refreshInterval: _SLOW_REFRESH_INTERVAL },\n  );\n}\n\nexport function useAllOpenOrdersBalances() {\n  const [\n    openOrdersAccounts,\n    loadedOpenOrdersAccounts,\n  ] = useAllOpenOrdersAccounts();\n  const [mintInfos, mintInfosConnected] = useMintInfos();\n  const [allMarkets] = useAllMarkets();\n  if (!loadedOpenOrdersAccounts || !mintInfosConnected) {\n    return {};\n  }\n\n  const marketsByAddress = Object.fromEntries(\n    (allMarkets || []).map((m) => [m.market.address.toBase58(), m]),\n  );\n  const openOrdersBalances: {\n    [mint: string]: { market: PublicKey; free: number; total: number }[];\n  } = {};\n  for (let account of openOrdersAccounts || []) {\n    const marketInfo = marketsByAddress[account.market.toBase58()];\n    const baseMint = marketInfo?.market.baseMintAddress.toBase58();\n    const quoteMint = marketInfo?.market.quoteMintAddress.toBase58();\n    if (!(baseMint in openOrdersBalances)) {\n      openOrdersBalances[baseMint] = [];\n    }\n    if (!(quoteMint in openOrdersBalances)) {\n      openOrdersBalances[quoteMint] = [];\n    }\n\n    const baseMintInfo = mintInfos && mintInfos[baseMint];\n    const baseFree = divideBnToNumber(\n      new BN(account.baseTokenFree),\n      getTokenMultiplierFromDecimals(baseMintInfo?.decimals || 0),\n    );\n    const baseTotal = divideBnToNumber(\n      new BN(account.baseTokenTotal),\n      getTokenMultiplierFromDecimals(baseMintInfo?.decimals || 0),\n    );\n    const quoteMintInfo = mintInfos && mintInfos[quoteMint];\n    const quoteFree = divideBnToNumber(\n      new BN(account.quoteTokenFree),\n      getTokenMultiplierFromDecimals(quoteMintInfo?.decimals || 0),\n    );\n    const quoteTotal = divideBnToNumber(\n      new BN(account.quoteTokenTotal),\n      getTokenMultiplierFromDecimals(quoteMintInfo?.decimals || 0),\n    );\n\n    openOrdersBalances[baseMint].push({\n      market: account.market,\n      free: baseFree,\n      total: baseTotal,\n    });\n    openOrdersBalances[quoteMint].push({\n      market: account.market,\n      free: quoteFree,\n      total: quoteTotal,\n    });\n  }\n  return openOrdersBalances;\n}\n\nexport const useAllOpenOrders = (): {\n  openOrders: { orders: Order[]; marketAddress: string }[] | null | undefined;\n  loaded: boolean;\n  refreshOpenOrders: () => void;\n} => {\n  const connection = useConnection();\n  const { connected, wallet } = useWallet();\n  const [loaded, setLoaded] = useState(false);\n  const [refresh, setRefresh] = useState(0);\n  const [openOrders, setOpenOrders] = useState<\n    { orders: Order[]; marketAddress: string }[] | null | undefined\n  >(null);\n  const [lastRefresh, setLastRefresh] = useState(0);\n\n  const refreshOpenOrders = () => {\n    if (new Date().getTime() - lastRefresh > 10 * 1000) {\n      setRefresh((prev) => prev + 1);\n    } else {\n      console.log('not refreshing');\n    }\n  };\n\n  useEffect(() => {\n    if (connected && wallet) {\n      const getAllOpenOrders = async () => {\n        setLoaded(false);\n        const _openOrders: { orders: Order[]; marketAddress: string }[] = [];\n        const getOpenOrdersForMarket = async (marketInfo: MarketInfo) => {\n          await sleep(1000 * Math.random()); // Try not to hit rate limit\n          try {\n            const market = await Market.load(\n              connection,\n              marketInfo.address,\n              undefined,\n              marketInfo.programId,\n            );\n            const orders = await market.loadOrdersForOwner(\n              connection,\n              wallet?.publicKey,\n              30000,\n            );\n            _openOrders.push({\n              orders: orders,\n              marketAddress: marketInfo.address.toBase58(),\n            });\n          } catch (e) {\n            console.warn(`Error loading open order ${marketInfo.name} - ${e}`);\n          }\n        };\n        await Promise.all(USE_MARKETS.map((m) => getOpenOrdersForMarket(m)));\n        setOpenOrders(_openOrders);\n        setLastRefresh(new Date().getTime());\n        setLoaded(true);\n      };\n      getAllOpenOrders();\n    }\n  }, [connection, connected, wallet, refresh]);\n  return {\n    openOrders: openOrders,\n    loaded: loaded,\n    refreshOpenOrders: refreshOpenOrders,\n  };\n};\n\nexport function useBalances(): Balances[] {\n  const baseCurrencyBalances = useSelectedBaseCurrencyBalances();\n  const quoteCurrencyBalances = useSelectedQuoteCurrencyBalances();\n  const openOrders = useSelectedOpenOrdersAccount(true);\n  const { baseCurrency, quoteCurrency, market } = useMarket();\n  const baseExists =\n    openOrders && openOrders.baseTokenTotal && openOrders.baseTokenFree;\n  const quoteExists =\n    openOrders && openOrders.quoteTokenTotal && openOrders.quoteTokenFree;\n  if (\n    baseCurrency === 'UNKNOWN' ||\n    quoteCurrency === 'UNKNOWN' ||\n    !baseCurrency ||\n    !quoteCurrency\n  ) {\n    return [];\n  }\n  return [\n    {\n      market,\n      key: `${baseCurrency}${quoteCurrency}${baseCurrency}`,\n      coin: baseCurrency,\n      wallet: baseCurrencyBalances,\n      orders:\n        baseExists && market && openOrders\n          ? market.baseSplSizeToNumber(\n              openOrders.baseTokenTotal.sub(openOrders.baseTokenFree),\n            )\n          : null,\n      openOrders,\n      unsettled:\n        baseExists && market && openOrders\n          ? market.baseSplSizeToNumber(openOrders.baseTokenFree)\n          : null,\n    },\n    {\n      market,\n      key: `${quoteCurrency}${baseCurrency}${quoteCurrency}`,\n      coin: quoteCurrency,\n      wallet: quoteCurrencyBalances,\n      openOrders,\n      orders:\n        quoteExists && market && openOrders\n          ? market.quoteSplSizeToNumber(\n              openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree),\n            )\n          : null,\n      unsettled:\n        quoteExists && market && openOrders\n          ? market.quoteSplSizeToNumber(openOrders.quoteTokenFree)\n          : null,\n    },\n  ];\n}\n\nexport function useWalletBalancesForAllMarkets(): {\n  mint: string;\n  balance: number;\n}[] {\n  const [tokenAccounts] = useTokenAccounts();\n  const { connected } = useWallet();\n  const [mintInfos, mintInfosConnected] = useMintInfos();\n\n  if (!connected || !mintInfosConnected) {\n    return [];\n  }\n\n  let balances: { [mint: string]: number } = {};\n  for (let account of tokenAccounts || []) {\n    if (!account.account) {\n      continue;\n    }\n    let parsedAccount;\n    if (account.effectiveMint.equals(WRAPPED_SOL_MINT)) {\n      parsedAccount = {\n        mint: WRAPPED_SOL_MINT,\n        owner: account.pubkey,\n        amount: account.account.lamports,\n      };\n    } else {\n      parsedAccount = parseTokenAccountData(account.account.data);\n    }\n    if (!(parsedAccount.mint.toBase58() in balances)) {\n      balances[parsedAccount.mint.toBase58()] = 0;\n    }\n    const mintInfo = mintInfos && mintInfos[parsedAccount.mint.toBase58()];\n    const additionalAmount = divideBnToNumber(\n      new BN(parsedAccount.amount),\n      getTokenMultiplierFromDecimals(mintInfo?.decimals || 0),\n    );\n    balances[parsedAccount.mint.toBase58()] += additionalAmount;\n  }\n  return Object.entries(balances).map(([mint, balance]) => {\n    return { mint, balance };\n  });\n}\n\nexport function useUnmigratedDeprecatedMarkets() {\n  const connection = useConnection();\n  const { accounts } = useUnmigratedOpenOrdersAccounts();\n  const marketsList =\n    accounts &&\n    Array.from(new Set(accounts.map((openOrders) => openOrders.market)));\n  const deps = marketsList && marketsList.map((m) => m.toBase58());\n\n  const useUnmigratedDeprecatedMarketsInner = async () => {\n    if (!marketsList) {\n      return null;\n    }\n    const getMarket = async (address) => {\n      const marketInfo = USE_MARKETS.find((market) =>\n        market.address.equals(address),\n      );\n      if (!marketInfo) {\n        console.log('Failed loading market');\n        notify({\n          message: 'Error loading market',\n          type: 'error',\n        });\n        return null;\n      }\n      try {\n        console.log('Loading market', marketInfo.name);\n        // NOTE: Should this just be cached by (connection, marketInfo.address, marketInfo.programId)?\n        return await Market.load(\n          connection,\n          marketInfo.address,\n          {},\n          marketInfo.programId,\n        );\n      } catch (e) {\n        console.log('Failed loading market', marketInfo.name, e);\n        notify({\n          message: 'Error loading market',\n          description: e.message,\n          type: 'error',\n        });\n        return null;\n      }\n    };\n    return (await Promise.all(marketsList.map(getMarket))).filter((x) => x);\n  };\n  const [markets] = useAsyncData(\n    useUnmigratedDeprecatedMarketsInner,\n    tuple(\n      'useUnmigratedDeprecatedMarketsInner',\n      connection,\n      deps && deps.toString(),\n    ),\n    { refreshInterval: _VERY_SLOW_REFRESH_INTERVAL },\n  );\n  if (!markets) {\n    return null;\n  }\n  return markets.map((market) => ({\n    market,\n    openOrdersList: accounts?.filter(\n      (openOrders) => market && openOrders.market.equals(market.address),\n    ),\n  }));\n}\n\nexport function useGetOpenOrdersForDeprecatedMarkets(): {\n  openOrders: OrderWithMarketAndMarketName[] | null | undefined;\n  loaded: boolean;\n  refreshOpenOrders: () => void;\n} {\n  const { connected, wallet } = useWallet();\n  const { customMarkets } = useCustomMarkets();\n  const connection = useConnection();\n  const marketsAndOrders = useUnmigratedDeprecatedMarkets();\n  const marketsList =\n    marketsAndOrders && marketsAndOrders.map(({ market }) => market);\n\n  // This isn't quite right: open order balances could change\n  const deps =\n    marketsList &&\n    marketsList\n      .filter((market): market is Market => !!market)\n      .map((market) => market.address.toBase58());\n\n  async function getOpenOrdersForDeprecatedMarkets() {\n    if (!connected || !wallet) {\n      return null;\n    }\n    if (!marketsList) {\n      return null;\n    }\n    console.log('refreshing getOpenOrdersForDeprecatedMarkets');\n    const getOrders = async (market: Market | null) => {\n      if (!market) {\n        return null;\n      }\n      const { marketName } = getMarketDetails(market, customMarkets);\n      try {\n        console.log('Fetching open orders for', marketName);\n        // Can do better than this, we have the open orders accounts already\n        return (\n          await market.loadOrdersForOwner(connection, wallet.publicKey)\n        ).map((order) => ({ marketName, market, ...order }));\n      } catch (e) {\n        console.log('Failed loading open orders', market.address.toBase58(), e);\n        notify({\n          message: `Error loading open orders for deprecated ${marketName}`,\n          description: e.message,\n          type: 'error',\n        });\n        return null;\n      }\n    };\n    return (await Promise.all(marketsList.map(getOrders)))\n      .filter((x): x is OrderWithMarketAndMarketName[] => !!x)\n      .flat();\n  }\n\n  const cacheKey = tuple(\n    'getOpenOrdersForDeprecatedMarkets',\n    connected,\n    connection,\n    wallet,\n    deps && deps.toString(),\n  );\n  const [openOrders, loaded] = useAsyncData(\n    getOpenOrdersForDeprecatedMarkets,\n    cacheKey,\n    {\n      refreshInterval: _VERY_SLOW_REFRESH_INTERVAL,\n    },\n  );\n  console.log('openOrders', openOrders);\n  return {\n    openOrders,\n    loaded,\n    refreshOpenOrders: () => refreshCache(cacheKey),\n  };\n}\n\nexport function useBalancesForDeprecatedMarkets() {\n  const markets = useUnmigratedDeprecatedMarkets();\n  const [customMarkets] = useLocalStorageState<CustomMarketInfo[]>(\n    'customMarkets',\n    [],\n  );\n  if (!markets) {\n    return null;\n  }\n\n  const openOrderAccountBalances: DeprecatedOpenOrdersBalances[] = [];\n  markets.forEach(({ market, openOrdersList }) => {\n    const { baseCurrency, quoteCurrency, marketName } = getMarketDetails(\n      market,\n      customMarkets,\n    );\n    if (!baseCurrency || !quoteCurrency || !market) {\n      return;\n    }\n    (openOrdersList || []).forEach((openOrders) => {\n      const inOrdersBase =\n        openOrders?.baseTokenTotal &&\n        openOrders?.baseTokenFree &&\n        market.baseSplSizeToNumber(\n          openOrders.baseTokenTotal.sub(openOrders.baseTokenFree),\n        );\n      const inOrdersQuote =\n        openOrders?.quoteTokenTotal &&\n        openOrders?.quoteTokenFree &&\n        market.baseSplSizeToNumber(\n          openOrders.quoteTokenTotal.sub(openOrders.quoteTokenFree),\n        );\n      const unsettledBase =\n        openOrders?.baseTokenFree &&\n        market.baseSplSizeToNumber(openOrders.baseTokenFree);\n      const unsettledQuote =\n        openOrders?.quoteTokenFree &&\n        market.baseSplSizeToNumber(openOrders.quoteTokenFree);\n\n      openOrderAccountBalances.push({\n        marketName,\n        market,\n        coin: baseCurrency,\n        key: `${marketName}${baseCurrency}`,\n        orders: inOrdersBase,\n        unsettled: unsettledBase,\n        openOrders,\n      });\n      openOrderAccountBalances.push({\n        marketName,\n        market,\n        coin: quoteCurrency,\n        key: `${marketName}${quoteCurrency}`,\n        orders: inOrdersQuote,\n        unsettled: unsettledQuote,\n        openOrders,\n      });\n    });\n  });\n  return openOrderAccountBalances;\n}\n\nexport function getMarketInfos(\n  customMarkets: CustomMarketInfo[],\n): MarketInfo[] {\n  const customMarketsInfo = customMarkets.map((m) => ({\n    ...m,\n    address: new PublicKey(m.address),\n    programId: new PublicKey(m.programId),\n    deprecated: false,\n  }));\n\n  return [...customMarketsInfo, ...USE_MARKETS];\n}\n\nexport function useMarketInfos() {\n  const { customMarkets } = useCustomMarkets();\n  return getMarketInfos(customMarkets);\n}\n\n/**\n * If selling, choose min tick size. If buying choose a price\n * s.t. given the state of the orderbook, the order will spend\n * `cost` cost currency.\n *\n * @param orderbook serum Orderbook object\n * @param cost quantity to spend. Base currency if selling,\n *  quote currency if buying.\n * @param tickSizeDecimals size of price increment of the market\n */\nexport function getMarketOrderPrice(\n  orderbook: Orderbook,\n  cost: number,\n  tickSizeDecimals?: number,\n) {\n  if (orderbook.isBids) {\n    return orderbook.market.tickSize;\n  }\n  let spentCost = 0;\n  let price, sizeAtLevel, costAtLevel: number;\n  const asks = orderbook.getL2(1000);\n  for ([price, sizeAtLevel] of asks) {\n    costAtLevel = price * sizeAtLevel;\n    if (spentCost + costAtLevel > cost) {\n      break;\n    }\n    spentCost += costAtLevel;\n  }\n  const sendPrice = Math.min(price * 1.02, asks[0][0] * 1.05);\n  let formattedPrice;\n  if (tickSizeDecimals) {\n    formattedPrice = floorToDecimal(sendPrice, tickSizeDecimals);\n  } else {\n    formattedPrice = sendPrice;\n  }\n  return formattedPrice;\n}\n\nexport function getExpectedFillPrice(\n  orderbook: Orderbook,\n  cost: number,\n  tickSizeDecimals?: number,\n) {\n  let spentCost = 0;\n  let avgPrice = 0;\n  let price, sizeAtLevel, costAtLevel: number;\n  for ([price, sizeAtLevel] of orderbook.getL2(1000)) {\n    costAtLevel = (orderbook.isBids ? 1 : price) * sizeAtLevel;\n    if (spentCost + costAtLevel > cost) {\n      avgPrice += (cost - spentCost) * price;\n      spentCost = cost;\n      break;\n    }\n    avgPrice += costAtLevel * price;\n    spentCost += costAtLevel;\n  }\n  const totalAvgPrice = avgPrice / Math.min(cost, spentCost);\n  let formattedPrice;\n  if (tickSizeDecimals) {\n    formattedPrice = floorToDecimal(totalAvgPrice, tickSizeDecimals);\n  } else {\n    formattedPrice = totalAvgPrice;\n  }\n  return formattedPrice;\n}\n\nexport function useCurrentlyAutoSettling(): [boolean, (currentlyAutoSettling: boolean) => void] {\n  const [currentlyAutoSettling, setCurrentlyAutosettling] = useState<boolean>(false);\n  return [currentlyAutoSettling, setCurrentlyAutosettling];\n}\n"]},"metadata":{},"sourceType":"module"}