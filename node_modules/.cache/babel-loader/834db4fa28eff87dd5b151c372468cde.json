{"ast":null,"code":"import * as BufferLayout from 'buffer-layout';\nimport bs58 from 'bs58';\nimport { PublicKey } from '@solana/web3.js';\nimport { WRAPPED_SOL_MINT } from '@project-serum/serum/lib/token-instructions';\nimport { TOKEN_MINTS } from '@project-serum/serum';\nimport { useAllMarkets, useCustomMarkets, useTokenAccounts } from './markets';\nimport { getMultipleSolanaAccounts } from './send';\nimport { useConnection } from './connection';\nimport { useAsyncData } from './fetch-loop';\nimport tuple from 'immutable-tuple';\nimport BN from 'bn.js';\nimport { useMemo } from 'react';\nexport const ACCOUNT_LAYOUT = BufferLayout.struct([BufferLayout.blob(32, 'mint'), BufferLayout.blob(32, 'owner'), BufferLayout.nu64('amount'), BufferLayout.blob(93)]);\nexport const MINT_LAYOUT = BufferLayout.struct([BufferLayout.blob(36), BufferLayout.blob(8, 'supply'), BufferLayout.u8('decimals'), BufferLayout.u8('initialized'), BufferLayout.blob(36)]);\nexport function parseTokenAccountData(data) {\n  let {\n    mint,\n    owner,\n    amount\n  } = ACCOUNT_LAYOUT.decode(data);\n  return {\n    mint: new PublicKey(mint),\n    owner: new PublicKey(owner),\n    amount\n  };\n}\nexport function parseTokenMintData(data) {\n  let {\n    decimals,\n    initialized,\n    supply\n  } = MINT_LAYOUT.decode(data);\n  return {\n    decimals,\n    initialized: !!initialized,\n    supply: new BN(supply, 10, 'le')\n  };\n}\nexport function getOwnedAccountsFilters(publicKey) {\n  return [{\n    memcmp: {\n      offset: ACCOUNT_LAYOUT.offsetOf('owner'),\n      bytes: publicKey.toBase58()\n    }\n  }, {\n    dataSize: ACCOUNT_LAYOUT.span\n  }];\n}\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\nexport async function getOwnedTokenAccounts(connection, publicKey) {\n  let filters = getOwnedAccountsFilters(publicKey); // @ts-ignore\n\n  let resp = await connection._rpcRequest('getProgramAccounts', [TOKEN_PROGRAM_ID.toBase58(), {\n    commitment: connection.commitment,\n    filters\n  }]);\n\n  if (resp.error) {\n    throw new Error('failed to get token accounts owned by ' + publicKey.toBase58() + ': ' + resp.error.message);\n  }\n\n  return resp.result.map(({\n    pubkey,\n    account: {\n      data,\n      executable,\n      owner,\n      lamports\n    }\n  }) => ({\n    publicKey: new PublicKey(pubkey),\n    accountInfo: {\n      data: bs58.decode(data),\n      executable,\n      owner: new PublicKey(owner),\n      lamports\n    }\n  })).filter(({\n    accountInfo\n  }) => {\n    // TODO: remove this check once mainnet is updated\n    return filters.every(filter => {\n      if (filter.dataSize) {\n        return accountInfo.data.length === filter.dataSize;\n      } else if (filter.memcmp) {\n        let filterBytes = bs58.decode(filter.memcmp.bytes);\n        return accountInfo.data.slice(filter.memcmp.offset, filter.memcmp.offset + filterBytes.length).equals(filterBytes);\n      }\n\n      return false;\n    });\n  });\n}\nexport async function getTokenAccountInfo(connection, ownerAddress) {\n  let [splAccounts, account] = await Promise.all([getOwnedTokenAccounts(connection, ownerAddress), connection.getAccountInfo(ownerAddress)]);\n  const parsedSplAccounts = splAccounts.map(({\n    publicKey,\n    accountInfo\n  }) => {\n    return {\n      pubkey: publicKey,\n      account: accountInfo,\n      effectiveMint: parseTokenAccountData(accountInfo.data).mint\n    };\n  });\n  return parsedSplAccounts.concat({\n    pubkey: ownerAddress,\n    account,\n    effectiveMint: WRAPPED_SOL_MINT\n  });\n} // todo: use this to map custom mints to custom tickers. Add functionality once custom markets store mints\n\nexport function useMintToTickers() {\n  const {\n    customMarkets\n  } = useCustomMarkets();\n  return useMemo(() => {\n    return Object.fromEntries(TOKEN_MINTS.map(mint => [mint.address.toBase58(), mint.name])); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [customMarkets.length]);\n}\n\nconst _VERY_SLOW_REFRESH_INTERVAL = 5000 * 1000; // todo: move this to using mints stored in static market infos once custom markets support that.\n\n\nexport function useMintInfos() {\n  const connection = useConnection();\n  const [tokenAccounts] = useTokenAccounts();\n  const [allMarkets] = useAllMarkets();\n  const allMints = (tokenAccounts || []).map(account => account.effectiveMint).concat((allMarkets || []).map(marketInfo => marketInfo.market.baseMintAddress)).concat((allMarkets || []).map(marketInfo => marketInfo.market.quoteMintAddress));\n  const uniqueMints = [...new Set(allMints.map(mint => mint.toBase58()))].map(stringMint => new PublicKey(stringMint));\n\n  const getAllMintInfo = async () => {\n    const mintInfos = await getMultipleSolanaAccounts(connection, uniqueMints);\n    return Object.fromEntries(Object.entries(mintInfos.value).map(([key, accountInfo]) => [key, accountInfo && parseTokenMintData(accountInfo.data)]));\n  };\n\n  return useAsyncData(getAllMintInfo, tuple('getAllMintInfo', connection, (tokenAccounts || []).length, (allMarkets || []).length), {\n    refreshInterval: _VERY_SLOW_REFRESH_INTERVAL\n  });\n}","map":{"version":3,"sources":["/mnt/c/Users/Gianni/Desktop/cooperaty-app/src/utils/tokens.tsx"],"names":["BufferLayout","bs58","PublicKey","WRAPPED_SOL_MINT","TOKEN_MINTS","useAllMarkets","useCustomMarkets","useTokenAccounts","getMultipleSolanaAccounts","useConnection","useAsyncData","tuple","BN","useMemo","ACCOUNT_LAYOUT","struct","blob","nu64","MINT_LAYOUT","u8","parseTokenAccountData","data","mint","owner","amount","decode","parseTokenMintData","decimals","initialized","supply","getOwnedAccountsFilters","publicKey","memcmp","offset","offsetOf","bytes","toBase58","dataSize","span","TOKEN_PROGRAM_ID","getOwnedTokenAccounts","connection","filters","resp","_rpcRequest","commitment","error","Error","message","result","map","pubkey","account","executable","lamports","accountInfo","filter","every","length","filterBytes","slice","equals","getTokenAccountInfo","ownerAddress","splAccounts","Promise","all","getAccountInfo","parsedSplAccounts","effectiveMint","concat","useMintToTickers","customMarkets","Object","fromEntries","address","name","_VERY_SLOW_REFRESH_INTERVAL","useMintInfos","tokenAccounts","allMarkets","allMints","marketInfo","market","baseMintAddress","quoteMintAddress","uniqueMints","Set","stringMint","getAllMintInfo","mintInfos","entries","value","key","refreshInterval"],"mappings":"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","sourcesContent":["import * as BufferLayout from 'buffer-layout';\nimport bs58 from 'bs58';\nimport {AccountInfo, Connection, PublicKey} from '@solana/web3.js';\nimport {WRAPPED_SOL_MINT} from '@project-serum/serum/lib/token-instructions';\nimport {TokenAccount} from './types';\nimport {TOKEN_MINTS} from '@project-serum/serum';\nimport {useAllMarkets, useCustomMarkets, useTokenAccounts} from './markets';\nimport {getMultipleSolanaAccounts} from './send';\nimport {useConnection} from './connection';\nimport {useAsyncData} from './fetch-loop';\nimport tuple from 'immutable-tuple';\nimport BN from 'bn.js';\nimport {useMemo} from 'react';\n\nexport const ACCOUNT_LAYOUT = BufferLayout.struct([\n  BufferLayout.blob(32, 'mint'),\n  BufferLayout.blob(32, 'owner'),\n  BufferLayout.nu64('amount'),\n  BufferLayout.blob(93),\n]);\n\nexport const MINT_LAYOUT = BufferLayout.struct([\n  BufferLayout.blob(36),\n  BufferLayout.blob(8, 'supply'),\n  BufferLayout.u8('decimals'),\n  BufferLayout.u8('initialized'),\n  BufferLayout.blob(36),\n]);\n\nexport function parseTokenAccountData(\n  data: Buffer,\n): { mint: PublicKey; owner: PublicKey; amount: number } {\n  let { mint, owner, amount } = ACCOUNT_LAYOUT.decode(data);\n  return {\n    mint: new PublicKey(mint),\n    owner: new PublicKey(owner),\n    amount,\n  };\n}\n\nexport interface MintInfo {\n  decimals: number;\n  initialized: boolean;\n  supply: BN;\n}\n\nexport function parseTokenMintData(data): MintInfo {\n  let { decimals, initialized, supply } = MINT_LAYOUT.decode(data);\n  return {\n    decimals,\n    initialized: !!initialized,\n    supply: new BN(supply, 10, 'le'),\n  };\n}\n\nexport function getOwnedAccountsFilters(publicKey: PublicKey) {\n  return [\n    {\n      memcmp: {\n        offset: ACCOUNT_LAYOUT.offsetOf('owner'),\n        bytes: publicKey.toBase58(),\n      },\n    },\n    {\n      dataSize: ACCOUNT_LAYOUT.span,\n    },\n  ];\n}\n\nexport const TOKEN_PROGRAM_ID = new PublicKey(\n  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n);\n\nexport async function getOwnedTokenAccounts(\n  connection: Connection,\n  publicKey: PublicKey,\n): Promise<Array<{ publicKey: PublicKey; accountInfo: AccountInfo<Buffer> }>> {\n  let filters = getOwnedAccountsFilters(publicKey);\n  // @ts-ignore\n  let resp = await connection._rpcRequest('getProgramAccounts', [\n    TOKEN_PROGRAM_ID.toBase58(),\n    {\n      commitment: connection.commitment,\n      filters,\n    },\n  ]);\n  if (resp.error) {\n    throw new Error(\n      'failed to get token accounts owned by ' +\n        publicKey.toBase58() +\n        ': ' +\n        resp.error.message,\n    );\n  }\n  return resp.result\n    .map(({ pubkey, account: { data, executable, owner, lamports } }) => ({\n      publicKey: new PublicKey(pubkey),\n      accountInfo: {\n        data: bs58.decode(data),\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n      },\n    }))\n    .filter(({ accountInfo }) => {\n      // TODO: remove this check once mainnet is updated\n      return filters.every((filter) => {\n        if (filter.dataSize) {\n          return accountInfo.data.length === filter.dataSize;\n        } else if (filter.memcmp) {\n          let filterBytes = bs58.decode(filter.memcmp.bytes);\n          return accountInfo.data\n            .slice(\n              filter.memcmp.offset,\n              filter.memcmp.offset + filterBytes.length,\n            )\n            .equals(filterBytes);\n        }\n        return false;\n      });\n    });\n}\n\nexport async function getTokenAccountInfo(\n  connection: Connection,\n  ownerAddress: PublicKey,\n) {\n  let [splAccounts, account] = await Promise.all([\n    getOwnedTokenAccounts(connection, ownerAddress),\n    connection.getAccountInfo(ownerAddress),\n  ]);\n  const parsedSplAccounts: TokenAccount[] = splAccounts.map(\n    ({ publicKey, accountInfo }) => {\n      return {\n        pubkey: publicKey,\n        account: accountInfo,\n        effectiveMint: parseTokenAccountData(accountInfo.data).mint,\n      };\n    },\n  );\n  return parsedSplAccounts.concat({\n    pubkey: ownerAddress,\n    account,\n    effectiveMint: WRAPPED_SOL_MINT,\n  });\n}\n\n// todo: use this to map custom mints to custom tickers. Add functionality once custom markets store mints\nexport function useMintToTickers(): { [mint: string]: string } {\n  const { customMarkets } = useCustomMarkets();\n  return useMemo(() => {\n    return Object.fromEntries(\n      TOKEN_MINTS.map((mint) => [mint.address.toBase58(), mint.name]),\n    );\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [customMarkets.length]);\n}\n\nconst _VERY_SLOW_REFRESH_INTERVAL = 5000 * 1000;\n\n// todo: move this to using mints stored in static market infos once custom markets support that.\nexport function useMintInfos(): [\n  (\n    | {\n        [mintAddress: string]: {\n          decimals: number;\n          initialized: boolean;\n        } | null;\n      }\n    | null\n    | undefined\n  ),\n  boolean,\n] {\n  const connection = useConnection();\n  const [tokenAccounts] = useTokenAccounts();\n  const [allMarkets] = useAllMarkets();\n\n  const allMints = (tokenAccounts || [])\n    .map((account) => account.effectiveMint)\n    .concat(\n      (allMarkets || []).map((marketInfo) => marketInfo.market.baseMintAddress),\n    )\n    .concat(\n      (allMarkets || []).map(\n        (marketInfo) => marketInfo.market.quoteMintAddress,\n      ),\n    );\n  const uniqueMints = [...new Set(allMints.map((mint) => mint.toBase58()))].map(\n    (stringMint) => new PublicKey(stringMint),\n  );\n\n  const getAllMintInfo = async () => {\n    const mintInfos = await getMultipleSolanaAccounts(connection, uniqueMints);\n    return Object.fromEntries(\n      Object.entries(mintInfos.value).map(([key, accountInfo]) => [\n        key,\n        accountInfo && parseTokenMintData(accountInfo.data),\n      ]),\n    );\n  };\n\n  return useAsyncData(\n    getAllMintInfo,\n    tuple(\n      'getAllMintInfo',\n      connection,\n      (tokenAccounts || []).length,\n      (allMarkets || []).length,\n    ),\n    { refreshInterval: _VERY_SLOW_REFRESH_INTERVAL },\n  );\n}\n"]},"metadata":{},"sourceType":"module"}