{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PoolTransactions = void 0;\n\nconst instructions_1 = require(\"./instructions\");\n\nconst web3_js_1 = require(\"@solana/web3.js\");\n\nconst serum_1 = require(\"@project-serum/serum\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst associated_token_1 = require(\"@project-serum/associated-token\");\n/**\n * High-level API for constructing transactions to interact with pools.\n *\n * For a lower-level API, see {@link PoolInstructions}.\n */\n\n\nclass PoolTransactions {\n  /**\n   * Transaction to initialize a simple pool.\n   *\n   * This will:\n   * - initialize a new pool token mint\n   * - initialize a pool token account for the creator and mint some tokens to it\n   * - initialize vault accounts for each of the pool assets\n   * - transfer assets from the pool creator to the vault accounts\n   * - initialize the pool\n   */\n  static async initializeSimplePool(params) {\n    const {\n      connection,\n      programId,\n      poolStateSpace,\n      poolMintDecimals = 6,\n      poolName,\n      assetMints,\n      initialPoolMintSupply = new bn_js_1.default('1' + '0'.repeat(poolMintDecimals)),\n      initialAssetQuantities,\n      creator,\n      creatorAssets,\n      feeRate = 2500,\n      additionalAccounts = []\n    } = params;\n\n    if (assetMints.length !== initialAssetQuantities.length) {\n      throw new Error('assetMints and initialAssetQuantities must have the same length');\n    }\n\n    if (assetMints.length !== creatorAssets.length) {\n      throw new Error('assetMints and creatorAssets must have the same length');\n    }\n\n    const poolStateAccount = new web3_js_1.Account();\n    const [vaultSigner, vaultSignerNonce] = await web3_js_1.PublicKey.findProgramAddress([poolStateAccount.publicKey.toBuffer()], programId);\n    const poolTokenMint = new web3_js_1.Account();\n    const creatorPoolTokenAddress = await associated_token_1.getAssociatedTokenAddress(creator, poolTokenMint.publicKey);\n    const vaultAddresses = await Promise.all(assetMints.map(mint => associated_token_1.getAssociatedTokenAddress(vaultSigner, mint)));\n    const lqdFeeAddress = await associated_token_1.getAssociatedTokenAddress(instructions_1.LQD_FEE_OWNER_ADDRESS, poolTokenMint.publicKey); // Split into two transactions to stay under the size limit.\n    // Ideally all instructions that transfer tokens happen in the second transaction,\n    // so they get reverted if the pool creation fails.\n\n    const setup = {\n      transaction: new web3_js_1.Transaction(),\n      signers: [poolTokenMint]\n    };\n    const finalize = {\n      transaction: new web3_js_1.Transaction(),\n      signers: [poolStateAccount]\n    };\n    const mintAccountSpace = 82;\n    const mintAccountLamports = await connection.getMinimumBalanceForRentExemption(mintAccountSpace); // Initialize pool token.\n\n    setup.transaction.add(web3_js_1.SystemProgram.createAccount({\n      fromPubkey: creator,\n      newAccountPubkey: poolTokenMint.publicKey,\n      space: mintAccountSpace,\n      lamports: mintAccountLamports,\n      programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID\n    }), serum_1.TokenInstructions.initializeMint({\n      mint: poolTokenMint.publicKey,\n      decimals: poolMintDecimals,\n      mintAuthority: creator\n    }), await associated_token_1.createAssociatedTokenAccount(creator, creator, poolTokenMint.publicKey), await associated_token_1.createAssociatedTokenAccount(creator, instructions_1.LQD_FEE_OWNER_ADDRESS, poolTokenMint.publicKey));\n    finalize.transaction.add(serum_1.TokenInstructions.mintTo({\n      mint: poolTokenMint.publicKey,\n      destination: creatorPoolTokenAddress,\n      amount: initialPoolMintSupply,\n      mintAuthority: creator\n    }), serum_1.TokenInstructions.setAuthority({\n      target: poolTokenMint.publicKey,\n      currentAuthority: creator,\n      newAuthority: vaultSigner,\n      authorityType: 0\n    })); // Initialize vault accounts.\n\n    await Promise.all(assetMints.map(async (mint, index) => {\n      const vault = vaultAddresses[index];\n      setup.transaction.add(await associated_token_1.createAssociatedTokenAccount(creator, vaultSigner, mint));\n      finalize.transaction.add(serum_1.TokenInstructions.transfer({\n        source: creatorAssets[index],\n        destination: vault,\n        amount: initialAssetQuantities[index],\n        owner: creator\n      }));\n    })); // Initialize pool account.\n\n    finalize.transaction.add(web3_js_1.SystemProgram.createAccount({\n      fromPubkey: creator,\n      newAccountPubkey: poolStateAccount.publicKey,\n      space: poolStateSpace,\n      lamports: await connection.getMinimumBalanceForRentExemption(poolStateSpace),\n      programId: programId\n    }), instructions_1.PoolInstructions.initialize(programId, poolStateAccount.publicKey, poolTokenMint.publicKey, poolName, vaultAddresses, vaultSigner, vaultSignerNonce, lqdFeeAddress, creatorPoolTokenAddress, feeRate, additionalAccounts));\n    return [poolStateAccount.publicKey, [setup, finalize]];\n  }\n  /**\n   * Transaction to get a pool basket, for use with simulateTransaction.\n   *\n   * This is a wrapper around {@link PoolInstructions.getBasket} that handles\n   * initializing the retbuf account.\n   *\n   * @param pool Pool to interact with.\n   * @param action Creation, redemption, or swap.\n   * @param payer Payer for fees. Must have nonzero SOL but will not be charged\n   * if the transaction is only simulated.\n   */\n\n\n  static getBasket(pool, action, payer) {\n    const transaction = new web3_js_1.Transaction();\n    const retbufAccount = new web3_js_1.Account();\n    transaction.add(web3_js_1.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: retbufAccount.publicKey,\n      lamports: 0,\n      space: 1024,\n      programId: instructions_1.RETBUF_PROGRAM_ID\n    }));\n    transaction.add(instructions_1.PoolInstructions.getBasket(pool, action, retbufAccount.publicKey));\n    transaction.feePayer = payer;\n    return {\n      transaction,\n      signers: [retbufAccount]\n    };\n  }\n  /**\n   * Transaction to execute a creation, redemption, or swap.\n   *\n   * This is a wrapper around {@link PoolInstructions.execute} that handles\n   * token delegation.\n   *\n   * The transaction will create a temporary account, delegate tokens to it,\n   * and use it in place of the actual owner, to limit the quantity of tokens\n   * that the pool can pull from the user's accounts.\n   *\n   * @param pool Pool to interact with.\n   * @param action Creation, redemption, or swap.\n   * @param user Token accounts to pull funds from or send funds to.\n   * @param expectedBasket Expected basket. Used to determine the quantity of\n   * tokens to approve.\n   */\n\n\n  static execute(pool, action, user, expectedBasket) {\n    if (expectedBasket.quantities.length !== pool.state.assets.length) {\n      throw new Error('expectedBasket must have the same number of components as the pool');\n    }\n\n    const transaction = new web3_js_1.Transaction();\n    const delegate = new web3_js_1.Account();\n    const signers = [delegate];\n    user = { ...user,\n      assetAccounts: user.assetAccounts.slice()\n    };\n    let wrappedSolAccount = null;\n\n    function approveDelegate(amount, index, approveZero = false) {\n      if (user.assetAccounts[index].equals(user.owner) && pool.state.assets[index].mint.equals(serum_1.TokenInstructions.WRAPPED_SOL_MINT)) {\n        wrappedSolAccount = new web3_js_1.Account();\n        signers.push(wrappedSolAccount);\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n          fromPubkey: user.owner,\n          newAccountPubkey: wrappedSolAccount.publicKey,\n          lamports: amount.toNumber() + 2.04e6,\n          space: 165,\n          programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID\n        }), serum_1.TokenInstructions.initializeAccount({\n          account: wrappedSolAccount.publicKey,\n          mint: serum_1.TokenInstructions.WRAPPED_SOL_MINT,\n          owner: delegate.publicKey\n        }));\n        user.assetAccounts[index] = wrappedSolAccount.publicKey;\n      } else if (amount.gtn(0) || approveZero) {\n        transaction.add(serum_1.TokenInstructions.approve({\n          owner: user.owner,\n          source: user.assetAccounts[index],\n          delegate: delegate.publicKey,\n          amount\n        }));\n      }\n    }\n\n    if ('create' in action) {\n      expectedBasket.quantities.forEach((amount, index) => {\n        approveDelegate(amount, index, true);\n      });\n    } else if ('redeem' in action) {\n      transaction.add(serum_1.TokenInstructions.approve({\n        owner: user.owner,\n        source: user.poolTokenAccount,\n        delegate: delegate.publicKey,\n        amount: action.redeem\n      }));\n      expectedBasket.quantities.forEach((amount, index) => {\n        if (amount.isNeg()) {\n          approveDelegate(amount.abs(), index);\n        } else {\n          approveDelegate(new bn_js_1.default(0), index);\n        }\n      });\n    } else if ('swap' in action) {\n      action.swap.quantities.forEach((amount, index) => {\n        approveDelegate(amount, index);\n      });\n    }\n\n    transaction.add(instructions_1.PoolInstructions.execute(pool, action, { ...user,\n      owner: delegate.publicKey\n    }));\n\n    if (wrappedSolAccount) {\n      transaction.add(serum_1.TokenInstructions.closeAccount({\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        source: wrappedSolAccount.publicKey,\n        destination: user.owner,\n        owner: delegate.publicKey\n      }));\n    }\n\n    return {\n      transaction,\n      signers\n    };\n  }\n\n}\n\nexports.PoolTransactions = PoolTransactions;","map":{"version":3,"sources":["../../src/transactions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PoolTransactions = void 0;\nconst instructions_1 = require(\"./instructions\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst serum_1 = require(\"@project-serum/serum\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst associated_token_1 = require(\"@project-serum/associated-token\");\n/**\n * High-level API for constructing transactions to interact with pools.\n *\n * For a lower-level API, see {@link PoolInstructions}.\n */\nclass PoolTransactions {\n    /**\n     * Transaction to initialize a simple pool.\n     *\n     * This will:\n     * - initialize a new pool token mint\n     * - initialize a pool token account for the creator and mint some tokens to it\n     * - initialize vault accounts for each of the pool assets\n     * - transfer assets from the pool creator to the vault accounts\n     * - initialize the pool\n     */\n    static async initializeSimplePool(params) {\n        const { connection, programId, poolStateSpace, poolMintDecimals = 6, poolName, assetMints, initialPoolMintSupply = new bn_js_1.default('1' + '0'.repeat(poolMintDecimals)), initialAssetQuantities, creator, creatorAssets, feeRate = 2500, additionalAccounts = [], } = params;\n        if (assetMints.length !== initialAssetQuantities.length) {\n            throw new Error('assetMints and initialAssetQuantities must have the same length');\n        }\n        if (assetMints.length !== creatorAssets.length) {\n            throw new Error('assetMints and creatorAssets must have the same length');\n        }\n        const poolStateAccount = new web3_js_1.Account();\n        const [vaultSigner, vaultSignerNonce] = await web3_js_1.PublicKey.findProgramAddress([poolStateAccount.publicKey.toBuffer()], programId);\n        const poolTokenMint = new web3_js_1.Account();\n        const creatorPoolTokenAddress = await associated_token_1.getAssociatedTokenAddress(creator, poolTokenMint.publicKey);\n        const vaultAddresses = await Promise.all(assetMints.map(mint => associated_token_1.getAssociatedTokenAddress(vaultSigner, mint)));\n        const lqdFeeAddress = await associated_token_1.getAssociatedTokenAddress(instructions_1.LQD_FEE_OWNER_ADDRESS, poolTokenMint.publicKey);\n        // Split into two transactions to stay under the size limit.\n        // Ideally all instructions that transfer tokens happen in the second transaction,\n        // so they get reverted if the pool creation fails.\n        const setup = {\n            transaction: new web3_js_1.Transaction(),\n            signers: [poolTokenMint],\n        };\n        const finalize = {\n            transaction: new web3_js_1.Transaction(),\n            signers: [poolStateAccount],\n        };\n        const mintAccountSpace = 82;\n        const mintAccountLamports = await connection.getMinimumBalanceForRentExemption(mintAccountSpace);\n        // Initialize pool token.\n        setup.transaction.add(web3_js_1.SystemProgram.createAccount({\n            fromPubkey: creator,\n            newAccountPubkey: poolTokenMint.publicKey,\n            space: mintAccountSpace,\n            lamports: mintAccountLamports,\n            programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,\n        }), serum_1.TokenInstructions.initializeMint({\n            mint: poolTokenMint.publicKey,\n            decimals: poolMintDecimals,\n            mintAuthority: creator,\n        }), await associated_token_1.createAssociatedTokenAccount(creator, creator, poolTokenMint.publicKey), await associated_token_1.createAssociatedTokenAccount(creator, instructions_1.LQD_FEE_OWNER_ADDRESS, poolTokenMint.publicKey));\n        finalize.transaction.add(serum_1.TokenInstructions.mintTo({\n            mint: poolTokenMint.publicKey,\n            destination: creatorPoolTokenAddress,\n            amount: initialPoolMintSupply,\n            mintAuthority: creator,\n        }), serum_1.TokenInstructions.setAuthority({\n            target: poolTokenMint.publicKey,\n            currentAuthority: creator,\n            newAuthority: vaultSigner,\n            authorityType: 0,\n        }));\n        // Initialize vault accounts.\n        await Promise.all(assetMints.map(async (mint, index) => {\n            const vault = vaultAddresses[index];\n            setup.transaction.add(await associated_token_1.createAssociatedTokenAccount(creator, vaultSigner, mint));\n            finalize.transaction.add(serum_1.TokenInstructions.transfer({\n                source: creatorAssets[index],\n                destination: vault,\n                amount: initialAssetQuantities[index],\n                owner: creator,\n            }));\n        }));\n        // Initialize pool account.\n        finalize.transaction.add(web3_js_1.SystemProgram.createAccount({\n            fromPubkey: creator,\n            newAccountPubkey: poolStateAccount.publicKey,\n            space: poolStateSpace,\n            lamports: await connection.getMinimumBalanceForRentExemption(poolStateSpace),\n            programId: programId,\n        }), instructions_1.PoolInstructions.initialize(programId, poolStateAccount.publicKey, poolTokenMint.publicKey, poolName, vaultAddresses, vaultSigner, vaultSignerNonce, lqdFeeAddress, creatorPoolTokenAddress, feeRate, additionalAccounts));\n        return [poolStateAccount.publicKey, [setup, finalize]];\n    }\n    /**\n     * Transaction to get a pool basket, for use with simulateTransaction.\n     *\n     * This is a wrapper around {@link PoolInstructions.getBasket} that handles\n     * initializing the retbuf account.\n     *\n     * @param pool Pool to interact with.\n     * @param action Creation, redemption, or swap.\n     * @param payer Payer for fees. Must have nonzero SOL but will not be charged\n     * if the transaction is only simulated.\n     */\n    static getBasket(pool, action, payer) {\n        const transaction = new web3_js_1.Transaction();\n        const retbufAccount = new web3_js_1.Account();\n        transaction.add(web3_js_1.SystemProgram.createAccount({\n            fromPubkey: payer,\n            newAccountPubkey: retbufAccount.publicKey,\n            lamports: 0,\n            space: 1024,\n            programId: instructions_1.RETBUF_PROGRAM_ID,\n        }));\n        transaction.add(instructions_1.PoolInstructions.getBasket(pool, action, retbufAccount.publicKey));\n        transaction.feePayer = payer;\n        return { transaction, signers: [retbufAccount] };\n    }\n    /**\n     * Transaction to execute a creation, redemption, or swap.\n     *\n     * This is a wrapper around {@link PoolInstructions.execute} that handles\n     * token delegation.\n     *\n     * The transaction will create a temporary account, delegate tokens to it,\n     * and use it in place of the actual owner, to limit the quantity of tokens\n     * that the pool can pull from the user's accounts.\n     *\n     * @param pool Pool to interact with.\n     * @param action Creation, redemption, or swap.\n     * @param user Token accounts to pull funds from or send funds to.\n     * @param expectedBasket Expected basket. Used to determine the quantity of\n     * tokens to approve.\n     */\n    static execute(pool, action, user, expectedBasket) {\n        if (expectedBasket.quantities.length !== pool.state.assets.length) {\n            throw new Error('expectedBasket must have the same number of components as the pool');\n        }\n        const transaction = new web3_js_1.Transaction();\n        const delegate = new web3_js_1.Account();\n        const signers = [delegate];\n        user = { ...user, assetAccounts: user.assetAccounts.slice() };\n        let wrappedSolAccount = null;\n        function approveDelegate(amount, index, approveZero = false) {\n            if (user.assetAccounts[index].equals(user.owner) &&\n                pool.state.assets[index].mint.equals(serum_1.TokenInstructions.WRAPPED_SOL_MINT)) {\n                wrappedSolAccount = new web3_js_1.Account();\n                signers.push(wrappedSolAccount);\n                transaction.add(web3_js_1.SystemProgram.createAccount({\n                    fromPubkey: user.owner,\n                    newAccountPubkey: wrappedSolAccount.publicKey,\n                    lamports: amount.toNumber() + 2.04e6,\n                    space: 165,\n                    programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,\n                }), serum_1.TokenInstructions.initializeAccount({\n                    account: wrappedSolAccount.publicKey,\n                    mint: serum_1.TokenInstructions.WRAPPED_SOL_MINT,\n                    owner: delegate.publicKey,\n                }));\n                user.assetAccounts[index] = wrappedSolAccount.publicKey;\n            }\n            else if (amount.gtn(0) || approveZero) {\n                transaction.add(serum_1.TokenInstructions.approve({\n                    owner: user.owner,\n                    source: user.assetAccounts[index],\n                    delegate: delegate.publicKey,\n                    amount,\n                }));\n            }\n        }\n        if ('create' in action) {\n            expectedBasket.quantities.forEach((amount, index) => {\n                approveDelegate(amount, index, true);\n            });\n        }\n        else if ('redeem' in action) {\n            transaction.add(serum_1.TokenInstructions.approve({\n                owner: user.owner,\n                source: user.poolTokenAccount,\n                delegate: delegate.publicKey,\n                amount: action.redeem,\n            }));\n            expectedBasket.quantities.forEach((amount, index) => {\n                if (amount.isNeg()) {\n                    approveDelegate(amount.abs(), index);\n                }\n                else {\n                    approveDelegate(new bn_js_1.default(0), index);\n                }\n            });\n        }\n        else if ('swap' in action) {\n            action.swap.quantities.forEach((amount, index) => {\n                approveDelegate(amount, index);\n            });\n        }\n        transaction.add(instructions_1.PoolInstructions.execute(pool, action, {\n            ...user,\n            owner: delegate.publicKey,\n        }));\n        if (wrappedSolAccount) {\n            transaction.add(serum_1.TokenInstructions.closeAccount({\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                source: wrappedSolAccount.publicKey,\n                destination: user.owner,\n                owner: delegate.publicKey,\n            }));\n        }\n        return { transaction, signers };\n    }\n}\nexports.PoolTransactions = PoolTransactions;\n//# sourceMappingURL=transactions.js.map"]},"metadata":{},"sourceType":"script"}