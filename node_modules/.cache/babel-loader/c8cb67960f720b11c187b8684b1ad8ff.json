{"ast":null,"code":"import { notify } from './notifications';\nimport { getDecimalCount, sleep } from './utils';\nimport { getSelectedTokenAccountForMint } from './markets';\nimport { Account, PublicKey, SystemProgram, Transaction } from '@solana/web3.js';\nimport { Token, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport BN from 'bn.js';\nimport { DexInstructions, Market, OpenOrders, parseInstructionErrorResponse, TOKEN_MINTS, TokenInstructions } from '@project-serum/serum';\nimport { Buffer } from 'buffer';\nimport assert from 'assert';\nimport { struct } from 'superstruct';\nexport async function createTokenAccountTransaction({\n  connection,\n  wallet,\n  mintPublicKey\n}) {\n  const ata = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mintPublicKey, wallet.publicKey);\n  const transaction = new Transaction();\n  transaction.add(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mintPublicKey, ata, wallet.publicKey, wallet.publicKey));\n  return {\n    transaction,\n    newAccountPubkey: ata\n  };\n}\nexport async function settleFunds({\n  market,\n  openOrders,\n  connection,\n  wallet,\n  baseCurrencyAccount,\n  quoteCurrencyAccount,\n  sendNotification = true,\n  usdcRef = undefined,\n  usdtRef = undefined\n}) {\n  if (!market || !wallet || !connection || !openOrders || !baseCurrencyAccount && !quoteCurrencyAccount) {\n    if (sendNotification) {\n      notify({\n        message: 'Not connected'\n      });\n    }\n\n    return;\n  }\n\n  let createAccountTransaction;\n  let baseCurrencyAccountPubkey = baseCurrencyAccount === null || baseCurrencyAccount === void 0 ? void 0 : baseCurrencyAccount.pubkey;\n  let quoteCurrencyAccountPubkey = quoteCurrencyAccount === null || quoteCurrencyAccount === void 0 ? void 0 : quoteCurrencyAccount.pubkey;\n\n  if (!baseCurrencyAccountPubkey) {\n    const result = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.baseMintAddress\n    });\n    baseCurrencyAccountPubkey = result === null || result === void 0 ? void 0 : result.newAccountPubkey;\n    createAccountTransaction = result === null || result === void 0 ? void 0 : result.transaction;\n  }\n\n  if (!quoteCurrencyAccountPubkey) {\n    const result = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.quoteMintAddress\n    });\n    quoteCurrencyAccountPubkey = result === null || result === void 0 ? void 0 : result.newAccountPubkey;\n    createAccountTransaction = result === null || result === void 0 ? void 0 : result.transaction;\n  }\n\n  let referrerQuoteWallet = null;\n\n  if (market.supportsReferralFees) {\n    const usdt = TOKEN_MINTS.find(({\n      name\n    }) => name === 'USDT');\n    const usdc = TOKEN_MINTS.find(({\n      name\n    }) => name === 'USDC');\n\n    if (usdtRef && usdt && market.quoteMintAddress.equals(usdt.address)) {\n      referrerQuoteWallet = usdtRef;\n    } else if (usdcRef && usdc && market.quoteMintAddress.equals(usdc.address)) {\n      referrerQuoteWallet = usdcRef;\n    }\n  }\n\n  const {\n    transaction: settleFundsTransaction,\n    signers: settleFundsSigners\n  } = await market.makeSettleFundsTransaction(connection, openOrders, baseCurrencyAccountPubkey, quoteCurrencyAccountPubkey, referrerQuoteWallet);\n  let transaction = mergeTransactions([createAccountTransaction, settleFundsTransaction]);\n  return await sendTransaction({\n    transaction,\n    signers: settleFundsSigners,\n    wallet,\n    connection,\n    sendingMessage: 'Settling funds...',\n    sendNotification\n  });\n}\nexport async function settleAllFunds({\n  connection,\n  wallet,\n  tokenAccounts,\n  markets,\n  selectedTokenAccounts\n}) {\n  if (!markets || !wallet || !connection || !tokenAccounts) {\n    return;\n  }\n\n  const programIds = [];\n  markets.reduce((cumulative, m) => {\n    // @ts-ignore\n    cumulative.push(m._programId);\n    return cumulative;\n  }, []).forEach(programId => {\n    if (!programIds.find(p => p.equals(programId))) {\n      programIds.push(programId);\n    }\n  });\n\n  const getOpenOrdersAccountsForProgramId = async programId => {\n    const openOrdersAccounts = await OpenOrders.findForOwner(connection, wallet.publicKey, programId);\n    return openOrdersAccounts.filter(openOrders => openOrders.baseTokenFree.toNumber() || openOrders.quoteTokenFree.toNumber());\n  };\n\n  const openOrdersAccountsForProgramIds = await Promise.all(programIds.map(programId => getOpenOrdersAccountsForProgramId(programId)));\n  const openOrdersAccounts = openOrdersAccountsForProgramIds.reduce((accounts, current) => accounts.concat(current), []);\n  const settleTransactions = (await Promise.all(openOrdersAccounts.map(openOrdersAccount => {\n    var _getSelectedTokenAcco, _getSelectedTokenAcco2;\n\n    const market = markets.find(m => {\n      var _m$_decoded, _m$_decoded$ownAddres;\n\n      return (// @ts-ignore\n        (_m$_decoded = m._decoded) === null || _m$_decoded === void 0 ? void 0 : (_m$_decoded$ownAddres = _m$_decoded.ownAddress) === null || _m$_decoded$ownAddres === void 0 ? void 0 : _m$_decoded$ownAddres.equals(openOrdersAccount.market)\n      );\n    });\n\n    if (openOrdersAccount.baseTokenFree.isZero() && openOrdersAccount.quoteTokenFree.isZero()) {\n      // nothing to settle for this market.\n      return null;\n    }\n\n    const baseMint = market === null || market === void 0 ? void 0 : market.baseMintAddress;\n    const quoteMint = market === null || market === void 0 ? void 0 : market.quoteMintAddress;\n    const selectedBaseTokenAccount = (_getSelectedTokenAcco = getSelectedTokenAccountForMint(tokenAccounts, baseMint, baseMint && selectedTokenAccounts && selectedTokenAccounts[baseMint.toBase58()])) === null || _getSelectedTokenAcco === void 0 ? void 0 : _getSelectedTokenAcco.pubkey;\n    const selectedQuoteTokenAccount = (_getSelectedTokenAcco2 = getSelectedTokenAccountForMint(tokenAccounts, quoteMint, quoteMint && selectedTokenAccounts && selectedTokenAccounts[quoteMint.toBase58()])) === null || _getSelectedTokenAcco2 === void 0 ? void 0 : _getSelectedTokenAcco2.pubkey;\n\n    if (!selectedBaseTokenAccount || !selectedQuoteTokenAccount) {\n      return null;\n    }\n\n    return market && market.makeSettleFundsTransaction(connection, openOrdersAccount, selectedBaseTokenAccount, selectedQuoteTokenAccount);\n  }))).filter(x => !!x);\n  if (!settleTransactions || settleTransactions.length === 0) return;\n  const transactions = settleTransactions.slice(0, 4).map(t => t.transaction);\n  const signers = [];\n  settleTransactions.reduce((cumulative, t) => cumulative.concat(t.signers), []).forEach(signer => {\n    if (!signers.find(s => s.publicKey.equals(signer.publicKey))) {\n      signers.push(signer);\n    }\n  });\n  const transaction = mergeTransactions(transactions);\n  return await sendTransaction({\n    transaction,\n    signers,\n    wallet,\n    connection\n  });\n}\nexport async function cancelOrder(params) {\n  return cancelOrders({ ...params,\n    orders: [params.order]\n  });\n}\nexport async function cancelOrders({\n  market,\n  wallet,\n  connection,\n  orders\n}) {\n  const transaction = market.makeMatchOrdersTransaction(5);\n  orders.forEach(order => {\n    transaction.add(market.makeCancelOrderInstruction(connection, wallet.publicKey, order));\n  });\n  transaction.add(market.makeMatchOrdersTransaction(5));\n  return await sendTransaction({\n    transaction,\n    wallet,\n    connection,\n    sendingMessage: 'Sending cancel...'\n  });\n}\nexport async function placeOrder({\n  side,\n  price,\n  size,\n  orderType,\n  market,\n  connection,\n  wallet,\n  baseCurrencyAccount,\n  quoteCurrencyAccount,\n  feeDiscountPubkey = undefined\n}) {\n  var _market$minOrderSize, _market$tickSize;\n\n  let formattedMinOrderSize = (market === null || market === void 0 ? void 0 : (_market$minOrderSize = market.minOrderSize) === null || _market$minOrderSize === void 0 ? void 0 : _market$minOrderSize.toFixed(getDecimalCount(market.minOrderSize))) || (market === null || market === void 0 ? void 0 : market.minOrderSize);\n  let formattedTickSize = (market === null || market === void 0 ? void 0 : (_market$tickSize = market.tickSize) === null || _market$tickSize === void 0 ? void 0 : _market$tickSize.toFixed(getDecimalCount(market.tickSize))) || (market === null || market === void 0 ? void 0 : market.tickSize);\n\n  const isIncrement = (num, step) => Math.abs(num / step % 1) < 1e-5 || Math.abs(num / step % 1 - 1) < 1e-5;\n\n  if (isNaN(price)) {\n    notify({\n      message: 'Invalid price',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (isNaN(size)) {\n    notify({\n      message: 'Invalid size',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!wallet || !wallet.publicKey) {\n    notify({\n      message: 'Connect wallet',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!market) {\n    notify({\n      message: 'Invalid  market',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!isIncrement(size, market.minOrderSize)) {\n    notify({\n      message: `Size must be an increment of ${formattedMinOrderSize}`,\n      type: 'error'\n    });\n    return;\n  }\n\n  if (size < market.minOrderSize) {\n    notify({\n      message: 'Size too small',\n      type: 'error'\n    });\n    return;\n  }\n\n  if (!isIncrement(price, market.tickSize)) {\n    notify({\n      message: `Price must be an increment of ${formattedTickSize}`,\n      type: 'error'\n    });\n    return;\n  }\n\n  if (price < market.tickSize) {\n    notify({\n      message: 'Price under tick size',\n      type: 'error'\n    });\n    return;\n  }\n\n  const owner = wallet.publicKey;\n  const transaction = new Transaction();\n  const signers = [];\n\n  if (!baseCurrencyAccount) {\n    const {\n      transaction: createAccountTransaction,\n      newAccountPubkey\n    } = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.baseMintAddress\n    });\n    transaction.add(createAccountTransaction);\n    baseCurrencyAccount = newAccountPubkey;\n  }\n\n  if (!quoteCurrencyAccount) {\n    const {\n      transaction: createAccountTransaction,\n      newAccountPubkey\n    } = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.quoteMintAddress\n    });\n    transaction.add(createAccountTransaction);\n    quoteCurrencyAccount = newAccountPubkey;\n  }\n\n  const payer = side === 'sell' ? baseCurrencyAccount : quoteCurrencyAccount;\n\n  if (!payer) {\n    notify({\n      message: 'Need an SPL token account for cost currency',\n      type: 'error'\n    });\n    return;\n  }\n\n  const params = {\n    owner,\n    payer,\n    side,\n    price,\n    size,\n    orderType,\n    feeDiscountPubkey: feeDiscountPubkey || null\n  };\n  console.log(params);\n  const matchOrderstransaction = market.makeMatchOrdersTransaction(5);\n  transaction.add(matchOrderstransaction);\n  const startTime = getUnixTs();\n  let {\n    transaction: placeOrderTx,\n    signers: placeOrderSigners\n  } = await market.makePlaceOrderTransaction(connection, params, 120000, 120000);\n  const endTime = getUnixTs();\n  console.log(`Creating order transaction took ${endTime - startTime}`);\n  transaction.add(placeOrderTx);\n  transaction.add(market.makeMatchOrdersTransaction(5));\n  signers.push(...placeOrderSigners);\n  return await sendTransaction({\n    transaction,\n    wallet,\n    connection,\n    signers,\n    sendingMessage: 'Sending order...'\n  });\n}\nexport async function listMarket({\n  connection,\n  wallet,\n  baseMint,\n  quoteMint,\n  baseLotSize,\n  quoteLotSize,\n  dexProgramId\n}) {\n  const market = new Account();\n  const requestQueue = new Account();\n  const eventQueue = new Account();\n  const bids = new Account();\n  const asks = new Account();\n  const baseVault = new Account();\n  const quoteVault = new Account();\n  const feeRateBps = 0;\n  const quoteDustThreshold = new BN(100);\n\n  async function getVaultOwnerAndNonce() {\n    const nonce = new BN(0);\n\n    while (true) {\n      try {\n        const vaultOwner = await PublicKey.createProgramAddress([market.publicKey.toBuffer(), nonce.toArrayLike(Buffer, 'le', 8)], dexProgramId);\n        return [vaultOwner, nonce];\n      } catch (e) {\n        nonce.iaddn(1);\n      }\n    }\n  }\n\n  const [vaultOwner, vaultSignerNonce] = await getVaultOwnerAndNonce();\n  const tx1 = new Transaction();\n  tx1.add(SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: baseVault.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(165),\n    space: 165,\n    programId: TokenInstructions.TOKEN_PROGRAM_ID\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: quoteVault.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(165),\n    space: 165,\n    programId: TokenInstructions.TOKEN_PROGRAM_ID\n  }), TokenInstructions.initializeAccount({\n    account: baseVault.publicKey,\n    mint: baseMint,\n    owner: vaultOwner\n  }), TokenInstructions.initializeAccount({\n    account: quoteVault.publicKey,\n    mint: quoteMint,\n    owner: vaultOwner\n  }));\n  const tx2 = new Transaction();\n  tx2.add(SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: market.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(Market.getLayout(dexProgramId).span),\n    space: Market.getLayout(dexProgramId).span,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: requestQueue.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(5120 + 12),\n    space: 5120 + 12,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: eventQueue.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(262144 + 12),\n    space: 262144 + 12,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: bids.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\n    space: 65536 + 12,\n    programId: dexProgramId\n  }), SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: asks.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\n    space: 65536 + 12,\n    programId: dexProgramId\n  }), DexInstructions.initializeMarket({\n    market: market.publicKey,\n    requestQueue: requestQueue.publicKey,\n    eventQueue: eventQueue.publicKey,\n    bids: bids.publicKey,\n    asks: asks.publicKey,\n    baseVault: baseVault.publicKey,\n    quoteVault: quoteVault.publicKey,\n    baseMint,\n    quoteMint,\n    baseLotSize: new BN(baseLotSize),\n    quoteLotSize: new BN(quoteLotSize),\n    feeRateBps,\n    vaultSignerNonce,\n    quoteDustThreshold,\n    programId: dexProgramId\n  }));\n  const signedTransactions = await signTransactions({\n    transactionsAndSigners: [{\n      transaction: tx1,\n      signers: [baseVault, quoteVault]\n    }, {\n      transaction: tx2,\n      signers: [market, requestQueue, eventQueue, bids, asks]\n    }],\n    wallet,\n    connection\n  });\n\n  for (let signedTransaction of signedTransactions) {\n    await sendSignedTransaction({\n      signedTransaction,\n      connection\n    });\n  }\n\n  return market.publicKey;\n}\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nconst DEFAULT_TIMEOUT = 15000;\nexport async function sendTransaction({\n  transaction,\n  wallet,\n  signers = [],\n  connection,\n  sendingMessage = 'Sending transaction...',\n  sentMessage = 'Transaction sent',\n  successMessage = 'Transaction confirmed',\n  timeout = DEFAULT_TIMEOUT,\n  sendNotification = true\n}) {\n  const signedTransaction = await signTransaction({\n    transaction,\n    wallet,\n    signers,\n    connection\n  });\n  return await sendSignedTransaction({\n    signedTransaction,\n    connection,\n    sendingMessage,\n    sentMessage,\n    successMessage,\n    timeout,\n    sendNotification\n  });\n}\nexport async function signTransaction({\n  transaction,\n  wallet,\n  signers = [],\n  connection\n}) {\n  transaction.recentBlockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  return await wallet.signTransaction(transaction);\n}\nexport async function signTransactions({\n  transactionsAndSigners,\n  wallet,\n  connection\n}) {\n  const blockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transactionsAndSigners.forEach(({\n    transaction,\n    signers = []\n  }) => {\n    transaction.recentBlockhash = blockhash;\n    transaction.setSigners(wallet.publicKey, ...signers.map(s => s.publicKey));\n\n    if ((signers === null || signers === void 0 ? void 0 : signers.length) > 0) {\n      transaction.partialSign(...signers);\n    }\n  });\n  return await wallet.signAllTransactions(transactionsAndSigners.map(({\n    transaction\n  }) => transaction));\n}\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  sendingMessage = 'Sending transaction...',\n  sentMessage = 'Transaction sent',\n  successMessage = 'Transaction confirmed',\n  timeout = DEFAULT_TIMEOUT,\n  sendNotification = true\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n\n  if (sendNotification) {\n    notify({\n      message: sendingMessage\n    });\n  }\n\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n\n  if (sendNotification) {\n    notify({\n      message: sentMessage,\n      type: 'success',\n      txid\n    });\n  }\n\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleep(300);\n    }\n  })();\n\n  try {\n    await awaitTransactionSignatureConfirmation(txid, timeout, connection);\n  } catch (err) {\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n\n    let simulateResult = null;\n\n    try {\n      simulateResult = (await simulateTransaction(connection, signedTransaction, 'single')).value;\n    } catch (e) {}\n\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n\n          if (line.startsWith('Program log: ')) {\n            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));\n          }\n        }\n      }\n\n      let parsedError;\n\n      if (typeof simulateResult.err == 'object' && 'InstructionError' in simulateResult.err) {\n        const parsedErrorInfo = parseInstructionErrorResponse(signedTransaction, simulateResult.err['InstructionError']);\n        parsedError = parsedErrorInfo.error;\n      } else {\n        parsedError = JSON.stringify(simulateResult.err);\n      }\n\n      throw new Error(parsedError);\n    }\n\n    throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  if (sendNotification) {\n    notify({\n      message: successMessage,\n      type: 'success',\n      txid\n    });\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return txid;\n}\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let done = false;\n  const result = await new Promise((resolve, reject) => {\n    (async () => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n\n        done = true;\n        console.log('Timed out for txid', txid);\n        reject({\n          timeout: true\n        });\n      }, timeout);\n\n      try {\n        connection.onSignature(txid, result => {\n          console.log('WS confirmed', txid, result);\n          done = true;\n\n          if (result.err) {\n            reject(result.err);\n          } else {\n            resolve(result);\n          }\n        }, 'recent');\n        console.log('Set up WS connection', txid);\n      } catch (e) {\n        done = true;\n        console.log('WS error in setup', txid, e);\n      }\n\n      while (!done) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([txid]);\n            const result = signatureStatuses && signatureStatuses.value[0];\n\n            if (!done) {\n              if (!result) {\n                console.log('REST null result for', txid, result);\n              } else if (result.err) {\n                console.log('REST error for', txid, result);\n                done = true;\n                reject(result.err);\n              } else if (!result.confirmations) {\n                console.log('REST no confirmations for', txid, result);\n              } else {\n                console.log('REST confirmation for', txid, result);\n                done = true;\n                resolve(result);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n\n        await sleep(300);\n      }\n    })();\n  });\n  done = true;\n  return result;\n}\n\nfunction mergeTransactions(transactions) {\n  const transaction = new Transaction();\n  transactions.filter(t => t !== undefined).forEach(t => {\n    transaction.add(t);\n  });\n  return transaction;\n}\n\nfunction jsonRpcResult(resultDescription) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([struct({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'any'\n  }), struct({\n    jsonrpc: jsonRpcVersion,\n    id: 'string',\n    error: 'null?',\n    result: resultDescription\n  })]);\n}\n\nfunction jsonRpcResultAndContext(resultDescription) {\n  return jsonRpcResult({\n    context: struct({\n      slot: 'number'\n    }),\n    value: resultDescription\n  });\n}\n\nconst AccountInfoResult = struct({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'any',\n  rentEpoch: 'number?'\n});\nexport const GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(struct.array([struct.union(['null', AccountInfoResult])]));\nexport async function getMultipleSolanaAccounts(connection, publicKeys) {\n  const args = [publicKeys.map(k => k.toBase58()), {\n    commitment: 'recent'\n  }]; // @ts-ignore\n\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  const res = GetMultipleAccountsAndContextRpcResult(unsafeRes);\n\n  if (res.error) {\n    throw new Error('failed to get info about accounts ' + publicKeys.map(k => k.toBase58()).join(', ') + ': ' + res.error.message);\n  }\n\n  assert(typeof res.result !== 'undefined');\n  const accounts = [];\n\n  for (const account of res.result.value) {\n    let value = null;\n\n    if (res.result.value) {\n      const {\n        executable,\n        owner,\n        lamports,\n        data\n      } = account;\n      assert(data[1] === 'base64');\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], 'base64')\n      };\n    }\n\n    accounts.push(value);\n  }\n\n  return {\n    context: {\n      slot: res.result.context.slot\n    },\n    value: Object.fromEntries(accounts.map((account, i) => [publicKeys[i].toBase58(), account]))\n  };\n}\n/** Copy of Connection.simulateTransaction that takes a commitment parameter. */\n\nasync function simulateTransaction(connection, transaction, commitment) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash( // @ts-ignore\n  connection._disableBlockhashCaching);\n  const signData = transaction.serializeMessage(); // @ts-ignore\n\n  const wireTransaction = transaction._serialize(signData);\n\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = {\n    encoding: 'base64',\n    commitment\n  };\n  const args = [encodedTransaction, config]; // @ts-ignore\n\n  const res = await connection._rpcRequest('simulateTransaction', args);\n\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n\n  return res.result;\n}","map":{"version":3,"sources":["/mnt/c/Users/Gianni/Desktop/cooperaty-app/src/utils/send.tsx"],"names":["notify","getDecimalCount","sleep","getSelectedTokenAccountForMint","Account","PublicKey","SystemProgram","Transaction","Token","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","BN","DexInstructions","Market","OpenOrders","parseInstructionErrorResponse","TOKEN_MINTS","TokenInstructions","Buffer","assert","struct","createTokenAccountTransaction","connection","wallet","mintPublicKey","ata","getAssociatedTokenAddress","publicKey","transaction","add","createAssociatedTokenAccountInstruction","newAccountPubkey","settleFunds","market","openOrders","baseCurrencyAccount","quoteCurrencyAccount","sendNotification","usdcRef","undefined","usdtRef","message","createAccountTransaction","baseCurrencyAccountPubkey","pubkey","quoteCurrencyAccountPubkey","result","baseMintAddress","quoteMintAddress","referrerQuoteWallet","supportsReferralFees","usdt","find","name","usdc","equals","address","settleFundsTransaction","signers","settleFundsSigners","makeSettleFundsTransaction","mergeTransactions","sendTransaction","sendingMessage","settleAllFunds","tokenAccounts","markets","selectedTokenAccounts","programIds","reduce","cumulative","m","push","_programId","forEach","programId","p","getOpenOrdersAccountsForProgramId","openOrdersAccounts","findForOwner","filter","baseTokenFree","toNumber","quoteTokenFree","openOrdersAccountsForProgramIds","Promise","all","map","accounts","current","concat","settleTransactions","openOrdersAccount","_decoded","ownAddress","isZero","baseMint","quoteMint","selectedBaseTokenAccount","toBase58","selectedQuoteTokenAccount","x","length","transactions","slice","t","signer","s","cancelOrder","params","cancelOrders","orders","order","makeMatchOrdersTransaction","makeCancelOrderInstruction","placeOrder","side","price","size","orderType","feeDiscountPubkey","formattedMinOrderSize","minOrderSize","toFixed","formattedTickSize","tickSize","isIncrement","num","step","Math","abs","isNaN","type","owner","payer","console","log","matchOrderstransaction","startTime","getUnixTs","placeOrderTx","placeOrderSigners","makePlaceOrderTransaction","endTime","listMarket","baseLotSize","quoteLotSize","dexProgramId","requestQueue","eventQueue","bids","asks","baseVault","quoteVault","feeRateBps","quoteDustThreshold","getVaultOwnerAndNonce","nonce","vaultOwner","createProgramAddress","toBuffer","toArrayLike","e","iaddn","vaultSignerNonce","tx1","createAccount","fromPubkey","lamports","getMinimumBalanceForRentExemption","space","initializeAccount","account","mint","tx2","getLayout","span","initializeMarket","signedTransactions","signTransactions","transactionsAndSigners","signedTransaction","sendSignedTransaction","Date","getTime","DEFAULT_TIMEOUT","sentMessage","successMessage","timeout","signTransaction","recentBlockhash","getRecentBlockhash","blockhash","setSigners","partialSign","signAllTransactions","rawTransaction","serialize","txid","sendRawTransaction","skipPreflight","done","awaitTransactionSignatureConfirmation","err","Error","simulateResult","simulateTransaction","value","logs","i","line","startsWith","parsedError","parsedErrorInfo","error","JSON","stringify","resolve","reject","setTimeout","onSignature","signatureStatuses","getSignatureStatuses","confirmations","jsonRpcResult","resultDescription","jsonRpcVersion","literal","union","jsonrpc","id","jsonRpcResultAndContext","context","slot","AccountInfoResult","executable","data","rentEpoch","GetMultipleAccountsAndContextRpcResult","array","getMultipleSolanaAccounts","publicKeys","args","k","commitment","unsafeRes","_rpcRequest","res","join","from","Object","fromEntries","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","config","encoding"],"mappings":"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","sourcesContent":["import { notify } from './notifications';\nimport { getDecimalCount, sleep } from './utils';\nimport { getSelectedTokenAccountForMint } from './markets';\nimport {\n  Account,\n  AccountInfo,\n  Commitment,\n  Connection,\n  PublicKey,\n  RpcResponseAndContext,\n  SimulatedTransactionResponse,\n  SystemProgram,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport {\n  Token,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n} from '@solana/spl-token';\nimport BN from 'bn.js';\nimport {\n  DexInstructions,\n  Market,\n  OpenOrders,\n  parseInstructionErrorResponse,\n  TOKEN_MINTS,\n  TokenInstructions,\n} from '@project-serum/serum';\nimport { SelectedTokenAccounts, TokenAccount } from './types';\nimport { Order } from '@project-serum/serum/lib/market';\nimport { Buffer } from 'buffer';\nimport assert from 'assert';\nimport { struct } from 'superstruct';\nimport { WalletAdapter } from '../wallet-adapters';\n\nexport async function createTokenAccountTransaction({\n  connection,\n  wallet,\n  mintPublicKey,\n}: {\n  connection: Connection;\n  wallet: WalletAdapter;\n  mintPublicKey: PublicKey;\n}): Promise<{\n  transaction: Transaction;\n  newAccountPubkey: PublicKey;\n}> {\n  const ata = await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    mintPublicKey,\n    wallet.publicKey,\n  );\n  const transaction = new Transaction();\n  transaction.add(\n    Token.createAssociatedTokenAccountInstruction(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      mintPublicKey,\n      ata,\n      wallet.publicKey,\n      wallet.publicKey,\n    ),\n  );\n  return {\n    transaction,\n    newAccountPubkey: ata,\n  };\n}\n\nexport async function settleFunds({\n  market,\n  openOrders,\n  connection,\n  wallet,\n  baseCurrencyAccount,\n  quoteCurrencyAccount,\n  sendNotification = true,\n  usdcRef = undefined,\n  usdtRef = undefined,\n}: {\n  market: Market;\n  openOrders: OpenOrders;\n  connection: Connection;\n  wallet: WalletAdapter;\n  baseCurrencyAccount: TokenAccount;\n  quoteCurrencyAccount: TokenAccount;\n  sendNotification?: boolean;\n  usdcRef?: PublicKey;\n  usdtRef?: PublicKey;\n}): Promise<string | undefined> {\n  if (\n    !market ||\n    !wallet ||\n    !connection ||\n    !openOrders ||\n    (!baseCurrencyAccount && !quoteCurrencyAccount)\n  ) {\n    if (sendNotification) {\n      notify({ message: 'Not connected' });\n    }\n    return;\n  }\n\n  let createAccountTransaction: Transaction | undefined;\n  let baseCurrencyAccountPubkey = baseCurrencyAccount?.pubkey;\n  let quoteCurrencyAccountPubkey = quoteCurrencyAccount?.pubkey;\n\n  if (!baseCurrencyAccountPubkey) {\n    const result = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.baseMintAddress,\n    });\n    baseCurrencyAccountPubkey = result?.newAccountPubkey;\n    createAccountTransaction = result?.transaction;\n  }\n  if (!quoteCurrencyAccountPubkey) {\n    const result = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.quoteMintAddress,\n    });\n    quoteCurrencyAccountPubkey = result?.newAccountPubkey;\n    createAccountTransaction = result?.transaction;\n  }\n  let referrerQuoteWallet: PublicKey | null = null;\n  if (market.supportsReferralFees) {\n    const usdt = TOKEN_MINTS.find(({ name }) => name === 'USDT');\n    const usdc = TOKEN_MINTS.find(({ name }) => name === 'USDC');\n    if (usdtRef && usdt && market.quoteMintAddress.equals(usdt.address)) {\n      referrerQuoteWallet = usdtRef;\n    } else if (\n      usdcRef &&\n      usdc &&\n      market.quoteMintAddress.equals(usdc.address)\n    ) {\n      referrerQuoteWallet = usdcRef;\n    }\n  }\n  const {\n    transaction: settleFundsTransaction,\n    signers: settleFundsSigners,\n  } = await market.makeSettleFundsTransaction(\n    connection,\n    openOrders,\n    baseCurrencyAccountPubkey,\n    quoteCurrencyAccountPubkey,\n    referrerQuoteWallet,\n  );\n\n  let transaction = mergeTransactions([\n    createAccountTransaction,\n    settleFundsTransaction,\n  ]);\n\n  return await sendTransaction({\n    transaction,\n    signers: settleFundsSigners,\n    wallet,\n    connection,\n    sendingMessage: 'Settling funds...',\n    sendNotification,\n  });\n}\n\nexport async function settleAllFunds({\n  connection,\n  wallet,\n  tokenAccounts,\n  markets,\n  selectedTokenAccounts,\n}: {\n  connection: Connection;\n  wallet: WalletAdapter;\n  tokenAccounts: TokenAccount[];\n  markets: Market[];\n  selectedTokenAccounts?: SelectedTokenAccounts;\n}) {\n  if (!markets || !wallet || !connection || !tokenAccounts) {\n    return;\n  }\n\n  const programIds: PublicKey[] = [];\n  markets\n    .reduce((cumulative, m) => {\n      // @ts-ignore\n      cumulative.push(m._programId);\n      return cumulative;\n    }, [])\n    .forEach((programId) => {\n      if (!programIds.find((p) => p.equals(programId))) {\n        programIds.push(programId);\n      }\n    });\n\n  const getOpenOrdersAccountsForProgramId = async (programId) => {\n    const openOrdersAccounts = await OpenOrders.findForOwner(\n      connection,\n      wallet.publicKey,\n      programId,\n    );\n    return openOrdersAccounts.filter(\n      (openOrders) =>\n        openOrders.baseTokenFree.toNumber() ||\n        openOrders.quoteTokenFree.toNumber(),\n    );\n  };\n\n  const openOrdersAccountsForProgramIds = await Promise.all(\n    programIds.map((programId) => getOpenOrdersAccountsForProgramId(programId)),\n  );\n  const openOrdersAccounts = openOrdersAccountsForProgramIds.reduce(\n    (accounts, current) => accounts.concat(current),\n    [],\n  );\n\n  const settleTransactions = (\n    await Promise.all(\n      openOrdersAccounts.map((openOrdersAccount) => {\n        const market = markets.find((m) =>\n          // @ts-ignore\n          m._decoded?.ownAddress?.equals(openOrdersAccount.market),\n        );\n        if (\n          openOrdersAccount.baseTokenFree.isZero() &&\n          openOrdersAccount.quoteTokenFree.isZero()\n        ) {\n          // nothing to settle for this market.\n          return null;\n        }\n        const baseMint = market?.baseMintAddress;\n        const quoteMint = market?.quoteMintAddress;\n\n        const selectedBaseTokenAccount = getSelectedTokenAccountForMint(\n          tokenAccounts,\n          baseMint,\n          baseMint &&\n            selectedTokenAccounts &&\n            selectedTokenAccounts[baseMint.toBase58()],\n        )?.pubkey;\n        const selectedQuoteTokenAccount = getSelectedTokenAccountForMint(\n          tokenAccounts,\n          quoteMint,\n          quoteMint &&\n            selectedTokenAccounts &&\n            selectedTokenAccounts[quoteMint.toBase58()],\n        )?.pubkey;\n        if (!selectedBaseTokenAccount || !selectedQuoteTokenAccount) {\n          return null;\n        }\n        return (\n          market &&\n          market.makeSettleFundsTransaction(\n            connection,\n            openOrdersAccount,\n            selectedBaseTokenAccount,\n            selectedQuoteTokenAccount,\n          )\n        );\n      }),\n    )\n  ).filter(\n    (\n      x,\n    ): x is {\n      signers: Account[];\n      transaction: Transaction;\n      payer: PublicKey;\n    } => !!x,\n  );\n  if (!settleTransactions || settleTransactions.length === 0) return;\n\n  const transactions = settleTransactions.slice(0, 4).map((t) => t.transaction);\n  const signers: Array<Account> = [];\n  settleTransactions\n    .reduce((cumulative: Array<Account>, t) => cumulative.concat(t.signers), [])\n    .forEach((signer) => {\n      if (!signers.find((s) => s.publicKey.equals(signer.publicKey))) {\n        signers.push(signer);\n      }\n    });\n\n  const transaction = mergeTransactions(transactions);\n\n  return await sendTransaction({\n    transaction,\n    signers,\n    wallet,\n    connection,\n  });\n}\n\nexport async function cancelOrder(params: {\n  market: Market;\n  connection: Connection;\n  wallet: WalletAdapter;\n  order: Order;\n}) {\n  return cancelOrders({ ...params, orders: [params.order] });\n}\n\nexport async function cancelOrders({\n  market,\n  wallet,\n  connection,\n  orders,\n}: {\n  market: Market;\n  wallet: WalletAdapter;\n  connection: Connection;\n  orders: Order[];\n}) {\n  const transaction = market.makeMatchOrdersTransaction(5);\n  orders.forEach((order) => {\n    transaction.add(\n      market.makeCancelOrderInstruction(connection, wallet.publicKey, order),\n    );\n  });\n  transaction.add(market.makeMatchOrdersTransaction(5));\n  return await sendTransaction({\n    transaction,\n    wallet,\n    connection,\n    sendingMessage: 'Sending cancel...',\n  });\n}\n\nexport async function placeOrder({\n  side,\n  price,\n  size,\n  orderType,\n  market,\n  connection,\n  wallet,\n  baseCurrencyAccount,\n  quoteCurrencyAccount,\n  feeDiscountPubkey = undefined,\n}: {\n  side: 'buy' | 'sell';\n  price: number;\n  size: number;\n  orderType: 'ioc' | 'postOnly' | 'limit';\n  market: Market | undefined | null;\n  connection: Connection;\n  wallet: WalletAdapter;\n  baseCurrencyAccount: PublicKey | undefined;\n  quoteCurrencyAccount: PublicKey | undefined;\n  feeDiscountPubkey: PublicKey | undefined;\n}) {\n  let formattedMinOrderSize =\n    market?.minOrderSize?.toFixed(getDecimalCount(market.minOrderSize)) ||\n    market?.minOrderSize;\n  let formattedTickSize =\n    market?.tickSize?.toFixed(getDecimalCount(market.tickSize)) ||\n    market?.tickSize;\n  const isIncrement = (num, step) =>\n    Math.abs((num / step) % 1) < 1e-5 ||\n    Math.abs(((num / step) % 1) - 1) < 1e-5;\n  if (isNaN(price)) {\n    notify({ message: 'Invalid price', type: 'error' });\n    return;\n  }\n  if (isNaN(size)) {\n    notify({ message: 'Invalid size', type: 'error' });\n    return;\n  }\n  if (!wallet || !wallet.publicKey) {\n    notify({ message: 'Connect wallet', type: 'error' });\n    return;\n  }\n  if (!market) {\n    notify({ message: 'Invalid  market', type: 'error' });\n    return;\n  }\n  if (!isIncrement(size, market.minOrderSize)) {\n    notify({\n      message: `Size must be an increment of ${formattedMinOrderSize}`,\n      type: 'error',\n    });\n    return;\n  }\n  if (size < market.minOrderSize) {\n    notify({ message: 'Size too small', type: 'error' });\n    return;\n  }\n  if (!isIncrement(price, market.tickSize)) {\n    notify({\n      message: `Price must be an increment of ${formattedTickSize}`,\n      type: 'error',\n    });\n    return;\n  }\n  if (price < market.tickSize) {\n    notify({ message: 'Price under tick size', type: 'error' });\n    return;\n  }\n  const owner = wallet.publicKey;\n  const transaction = new Transaction();\n  const signers: Account[] = [];\n\n  if (!baseCurrencyAccount) {\n    const {\n      transaction: createAccountTransaction,\n      newAccountPubkey,\n    } = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.baseMintAddress,\n    });\n    transaction.add(createAccountTransaction);\n    baseCurrencyAccount = newAccountPubkey;\n  }\n  if (!quoteCurrencyAccount) {\n    const {\n      transaction: createAccountTransaction,\n      newAccountPubkey,\n    } = await createTokenAccountTransaction({\n      connection,\n      wallet,\n      mintPublicKey: market.quoteMintAddress,\n    });\n    transaction.add(createAccountTransaction);\n    quoteCurrencyAccount = newAccountPubkey;\n  }\n\n  const payer = side === 'sell' ? baseCurrencyAccount : quoteCurrencyAccount;\n  if (!payer) {\n    notify({\n      message: 'Need an SPL token account for cost currency',\n      type: 'error',\n    });\n    return;\n  }\n  const params = {\n    owner,\n    payer,\n    side,\n    price,\n    size,\n    orderType,\n    feeDiscountPubkey: feeDiscountPubkey || null,\n  };\n  console.log(params);\n\n  const matchOrderstransaction = market.makeMatchOrdersTransaction(5);\n  transaction.add(matchOrderstransaction);\n  const startTime = getUnixTs();\n  let {\n    transaction: placeOrderTx,\n    signers: placeOrderSigners,\n  } = await market.makePlaceOrderTransaction(\n    connection,\n    params,\n    120_000,\n    120_000,\n  );\n  const endTime = getUnixTs();\n  console.log(`Creating order transaction took ${endTime - startTime}`);\n  transaction.add(placeOrderTx);\n  transaction.add(market.makeMatchOrdersTransaction(5));\n  signers.push(...placeOrderSigners);\n\n  return await sendTransaction({\n    transaction,\n    wallet,\n    connection,\n    signers,\n    sendingMessage: 'Sending order...',\n  });\n}\n\nexport async function listMarket({\n  connection,\n  wallet,\n  baseMint,\n  quoteMint,\n  baseLotSize,\n  quoteLotSize,\n  dexProgramId,\n}: {\n  connection: Connection;\n  wallet: WalletAdapter;\n  baseMint: PublicKey;\n  quoteMint: PublicKey;\n  baseLotSize: number;\n  quoteLotSize: number;\n  dexProgramId: PublicKey;\n}) {\n  const market = new Account();\n  const requestQueue = new Account();\n  const eventQueue = new Account();\n  const bids = new Account();\n  const asks = new Account();\n  const baseVault = new Account();\n  const quoteVault = new Account();\n  const feeRateBps = 0;\n  const quoteDustThreshold = new BN(100);\n\n  async function getVaultOwnerAndNonce() {\n    const nonce = new BN(0);\n    while (true) {\n      try {\n        const vaultOwner = await PublicKey.createProgramAddress(\n          [market.publicKey.toBuffer(), nonce.toArrayLike(Buffer, 'le', 8)],\n          dexProgramId,\n        );\n        return [vaultOwner, nonce];\n      } catch (e) {\n        nonce.iaddn(1);\n      }\n    }\n  }\n  const [vaultOwner, vaultSignerNonce] = await getVaultOwnerAndNonce();\n\n  const tx1 = new Transaction();\n  tx1.add(\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: baseVault.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(165),\n      space: 165,\n      programId: TokenInstructions.TOKEN_PROGRAM_ID,\n    }),\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: quoteVault.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(165),\n      space: 165,\n      programId: TokenInstructions.TOKEN_PROGRAM_ID,\n    }),\n    TokenInstructions.initializeAccount({\n      account: baseVault.publicKey,\n      mint: baseMint,\n      owner: vaultOwner,\n    }),\n    TokenInstructions.initializeAccount({\n      account: quoteVault.publicKey,\n      mint: quoteMint,\n      owner: vaultOwner,\n    }),\n  );\n\n  const tx2 = new Transaction();\n  tx2.add(\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: market.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(\n        Market.getLayout(dexProgramId).span,\n      ),\n      space: Market.getLayout(dexProgramId).span,\n      programId: dexProgramId,\n    }),\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: requestQueue.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(5120 + 12),\n      space: 5120 + 12,\n      programId: dexProgramId,\n    }),\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: eventQueue.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(262144 + 12),\n      space: 262144 + 12,\n      programId: dexProgramId,\n    }),\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: bids.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\n      space: 65536 + 12,\n      programId: dexProgramId,\n    }),\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: asks.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(65536 + 12),\n      space: 65536 + 12,\n      programId: dexProgramId,\n    }),\n    DexInstructions.initializeMarket({\n      market: market.publicKey,\n      requestQueue: requestQueue.publicKey,\n      eventQueue: eventQueue.publicKey,\n      bids: bids.publicKey,\n      asks: asks.publicKey,\n      baseVault: baseVault.publicKey,\n      quoteVault: quoteVault.publicKey,\n      baseMint,\n      quoteMint,\n      baseLotSize: new BN(baseLotSize),\n      quoteLotSize: new BN(quoteLotSize),\n      feeRateBps,\n      vaultSignerNonce,\n      quoteDustThreshold,\n      programId: dexProgramId,\n    }),\n  );\n\n  const signedTransactions = await signTransactions({\n    transactionsAndSigners: [\n      { transaction: tx1, signers: [baseVault, quoteVault] },\n      {\n        transaction: tx2,\n        signers: [market, requestQueue, eventQueue, bids, asks],\n      },\n    ],\n    wallet,\n    connection,\n  });\n  for (let signedTransaction of signedTransactions) {\n    await sendSignedTransaction({\n      signedTransaction,\n      connection,\n    });\n  }\n\n  return market.publicKey;\n}\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendTransaction({\n  transaction,\n  wallet,\n  signers = [],\n  connection,\n  sendingMessage = 'Sending transaction...',\n  sentMessage = 'Transaction sent',\n  successMessage = 'Transaction confirmed',\n  timeout = DEFAULT_TIMEOUT,\n  sendNotification = true,\n}: {\n  transaction: Transaction;\n  wallet: WalletAdapter;\n  signers?: Array<Account>;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n  sendNotification?: boolean;\n}) {\n  const signedTransaction = await signTransaction({\n    transaction,\n    wallet,\n    signers,\n    connection,\n  });\n  return await sendSignedTransaction({\n    signedTransaction,\n    connection,\n    sendingMessage,\n    sentMessage,\n    successMessage,\n    timeout,\n    sendNotification,\n  });\n}\n\nexport async function signTransaction({\n  transaction,\n  wallet,\n  signers = [],\n  connection,\n}: {\n  transaction: Transaction;\n  wallet: WalletAdapter;\n  signers?: Array<Account>;\n  connection: Connection;\n}) {\n  transaction.recentBlockhash = (\n    await connection.getRecentBlockhash('max')\n  ).blockhash;\n  transaction.setSigners(wallet.publicKey, ...signers.map((s) => s.publicKey));\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  return await wallet.signTransaction(transaction);\n}\n\nexport async function signTransactions({\n  transactionsAndSigners,\n  wallet,\n  connection,\n}: {\n  transactionsAndSigners: {\n    transaction: Transaction;\n    signers?: Array<Account>;\n  }[];\n  wallet: WalletAdapter;\n  connection: Connection;\n}) {\n  const blockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transactionsAndSigners.forEach(({ transaction, signers = [] }) => {\n    transaction.recentBlockhash = blockhash;\n    transaction.setSigners(\n      wallet.publicKey,\n      ...signers.map((s) => s.publicKey),\n    );\n    if (signers?.length > 0) {\n      transaction.partialSign(...signers);\n    }\n  });\n  return await wallet.signAllTransactions(\n    transactionsAndSigners.map(({ transaction }) => transaction),\n  );\n}\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  sendingMessage = 'Sending transaction...',\n  sentMessage = 'Transaction sent',\n  successMessage = 'Transaction confirmed',\n  timeout = DEFAULT_TIMEOUT,\n  sendNotification = true,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n  sendNotification?: boolean;\n}): Promise<string> {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  if (sendNotification) {\n    notify({ message: sendingMessage });\n  }\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n  if (sendNotification) {\n    notify({ message: sentMessage, type: 'success', txid });\n  }\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(300);\n    }\n  })();\n  try {\n    await awaitTransactionSignatureConfirmation(txid, timeout, connection);\n  } catch (err) {\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      let parsedError;\n      if (\n        typeof simulateResult.err == 'object' &&\n        'InstructionError' in simulateResult.err\n      ) {\n        const parsedErrorInfo = parseInstructionErrorResponse(\n          signedTransaction,\n          simulateResult.err['InstructionError'],\n        );\n        parsedError = parsedErrorInfo.error;\n      } else {\n        parsedError = JSON.stringify(simulateResult.err);\n      }\n      throw new Error(parsedError);\n    }\n    throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n  if (sendNotification) {\n    notify({ message: successMessage, type: 'success', txid });\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return txid;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n) {\n  let done = false;\n  const result = await new Promise((resolve, reject) => {\n    (async () => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n        done = true;\n        console.log('Timed out for txid', txid);\n        reject({ timeout: true });\n      }, timeout);\n      try {\n        connection.onSignature(\n          txid,\n          (result) => {\n            console.log('WS confirmed', txid, result);\n            done = true;\n            if (result.err) {\n              reject(result.err);\n            } else {\n              resolve(result);\n            }\n          },\n          'recent',\n        );\n        console.log('Set up WS connection', txid);\n      } catch (e) {\n        done = true;\n        console.log('WS error in setup', txid, e);\n      }\n      while (!done) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([\n              txid,\n            ]);\n            const result = signatureStatuses && signatureStatuses.value[0];\n            if (!done) {\n              if (!result) {\n                console.log('REST null result for', txid, result);\n              } else if (result.err) {\n                console.log('REST error for', txid, result);\n                done = true;\n                reject(result.err);\n              } else if (!result.confirmations) {\n                console.log('REST no confirmations for', txid, result);\n              } else {\n                console.log('REST confirmation for', txid, result);\n                done = true;\n                resolve(result);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n        await sleep(300);\n      }\n    })();\n  });\n  done = true;\n  return result;\n}\n\nfunction mergeTransactions(transactions: (Transaction | undefined)[]) {\n  const transaction = new Transaction();\n  transactions\n    .filter((t): t is Transaction => t !== undefined)\n    .forEach((t) => {\n      transaction.add(t);\n    });\n  return transaction;\n}\n\nfunction jsonRpcResult(resultDescription: any) {\n  const jsonRpcVersion = struct.literal('2.0');\n  return struct.union([\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'any',\n    }),\n    struct({\n      jsonrpc: jsonRpcVersion,\n      id: 'string',\n      error: 'null?',\n      result: resultDescription,\n    }),\n  ]);\n}\n\nfunction jsonRpcResultAndContext(resultDescription: any) {\n  return jsonRpcResult({\n    context: struct({\n      slot: 'number',\n    }),\n    value: resultDescription,\n  });\n}\n\nconst AccountInfoResult = struct({\n  executable: 'boolean',\n  owner: 'string',\n  lamports: 'number',\n  data: 'any',\n  rentEpoch: 'number?',\n});\n\nexport const GetMultipleAccountsAndContextRpcResult = jsonRpcResultAndContext(\n  struct.array([struct.union(['null', AccountInfoResult])]),\n);\n\nexport async function getMultipleSolanaAccounts(\n  connection: Connection,\n  publicKeys: PublicKey[],\n): Promise<\n  RpcResponseAndContext<{ [key: string]: AccountInfo<Buffer> | null }>\n> {\n  const args = [publicKeys.map((k) => k.toBase58()), { commitment: 'recent' }];\n  // @ts-ignore\n  const unsafeRes = await connection._rpcRequest('getMultipleAccounts', args);\n  const res = GetMultipleAccountsAndContextRpcResult(unsafeRes);\n  if (res.error) {\n    throw new Error(\n      'failed to get info about accounts ' +\n        publicKeys.map((k) => k.toBase58()).join(', ') +\n        ': ' +\n        res.error.message,\n    );\n  }\n  assert(typeof res.result !== 'undefined');\n  const accounts: Array<{\n    executable: any;\n    owner: PublicKey;\n    lamports: any;\n    data: Buffer;\n  } | null> = [];\n  for (const account of res.result.value) {\n    let value: {\n      executable: any;\n      owner: PublicKey;\n      lamports: any;\n      data: Buffer;\n    } | null = null;\n    if (res.result.value) {\n      const { executable, owner, lamports, data } = account;\n      assert(data[1] === 'base64');\n      value = {\n        executable,\n        owner: new PublicKey(owner),\n        lamports,\n        data: Buffer.from(data[0], 'base64'),\n      };\n    }\n    accounts.push(value);\n  }\n  return {\n    context: {\n      slot: res.result.context.slot,\n    },\n    value: Object.fromEntries(\n      accounts.map((account, i) => [publicKeys[i].toBase58(), account]),\n    ),\n  };\n}\n\n/** Copy of Connection.simulateTransaction that takes a commitment parameter. */\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n"]},"metadata":{},"sourceType":"module"}