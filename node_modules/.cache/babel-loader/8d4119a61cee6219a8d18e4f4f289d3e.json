{"ast":null,"code":"var _jsxFileName = \"/mnt/c/Users/Gianni/Desktop/serum-dex-ui/src/utils/connection.tsx\";\nimport { useLocalStorageState } from './utils';\nimport { Account, Connection } from '@solana/web3.js';\nimport React, { useContext, useEffect, useMemo, useRef } from 'react';\nimport { setCache, useAsyncData } from './fetch-loop';\nimport tuple from 'immutable-tuple';\nexport const ENDPOINTS = [{\n  name: 'mainnet-beta',\n  endpoint: 'https://solana-api.projectserum.com',\n  custom: false\n}, {\n  name: 'localnet',\n  endpoint: 'http://127.0.0.1:8899',\n  custom: false\n}];\nconst accountListenerCount = new Map();\nconst ConnectionContext = React.createContext(null);\nexport function ConnectionProvider({\n  children\n}) {\n  const [endpoint, setEndpoint] = useLocalStorageState('connectionEndpts', ENDPOINTS[0].endpoint);\n  const [customEndpoints, setCustomEndpoints] = useLocalStorageState('customConnectionEndpoints', []);\n  const availableEndpoints = ENDPOINTS.concat(customEndpoints);\n  const connection = useMemo(() => new Connection(endpoint, 'recent'), [endpoint]);\n  const sendConnection = useMemo(() => new Connection(endpoint, 'recent'), [endpoint]); // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n\n  useEffect(() => {\n    const id = connection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n  useEffect(() => {\n    const id = sendConnection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      sendConnection.removeAccountChangeListener(id);\n    };\n  }, [sendConnection]);\n  useEffect(() => {\n    const id = sendConnection.onSlotChange(() => null);\n    return () => {\n      sendConnection.removeSlotChangeListener(id);\n    };\n  }, [sendConnection]);\n  return /*#__PURE__*/React.createElement(ConnectionContext.Provider, {\n    value: {\n      endpoint,\n      setEndpoint,\n      connection,\n      sendConnection,\n      availableEndpoints,\n      setCustomEndpoints\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 75,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useConnection() {\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return context.connection;\n}\nexport function useSendConnection() {\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return context.sendConnection;\n}\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n\n  return {\n    endpoint: context.endpoint,\n    endpointInfo: context.availableEndpoints.find(info => info.endpoint === context.endpoint),\n    setEndpoint: context.setEndpoint,\n    availableEndpoints: context.availableEndpoints,\n    setCustomEndpoints: context.setCustomEndpoints\n  };\n}\nexport function useAccountInfo(publicKey) {\n  const connection = useConnection();\n  const cacheKey = tuple(connection, publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58());\n  const [accountInfo, loaded] = useAsyncData(async () => publicKey ? connection.getAccountInfo(publicKey) : null, cacheKey, {\n    refreshInterval: 60000\n  });\n  useEffect(() => {\n    if (!publicKey) {\n      return;\n    }\n\n    if (accountListenerCount.has(cacheKey)) {\n      let currentItem = accountListenerCount.get(cacheKey);\n      ++currentItem.count;\n    } else {\n      let previousInfo = null;\n      const subscriptionId = connection.onAccountChange(publicKey, info => {\n        if (!previousInfo || !previousInfo.data.equals(info.data) || previousInfo.lamports !== info.lamports) {\n          previousInfo = info;\n          setCache(cacheKey, info);\n        }\n      });\n      accountListenerCount.set(cacheKey, {\n        count: 1,\n        subscriptionId\n      });\n    }\n\n    return () => {\n      let currentItem = accountListenerCount.get(cacheKey);\n      let nextCount = currentItem.count - 1;\n\n      if (nextCount <= 0) {\n        connection.removeAccountChangeListener(currentItem.subscriptionId);\n        accountListenerCount.delete(cacheKey);\n      } else {\n        --currentItem.count;\n      }\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey]);\n  const previousInfoRef = useRef(null);\n\n  if (!accountInfo || !previousInfoRef.current || !previousInfoRef.current.data.equals(accountInfo.data) || previousInfoRef.current.lamports !== accountInfo.lamports) {\n    previousInfoRef.current = accountInfo;\n  }\n\n  return [previousInfoRef.current, loaded];\n}\nexport function useAccountData(publicKey) {\n  const [accountInfo] = useAccountInfo(publicKey);\n  return accountInfo && accountInfo.data;\n}","map":{"version":3,"sources":["/mnt/c/Users/Gianni/Desktop/serum-dex-ui/src/utils/connection.tsx"],"names":["useLocalStorageState","Account","Connection","React","useContext","useEffect","useMemo","useRef","setCache","useAsyncData","tuple","ENDPOINTS","name","endpoint","custom","accountListenerCount","Map","ConnectionContext","createContext","ConnectionProvider","children","setEndpoint","customEndpoints","setCustomEndpoints","availableEndpoints","concat","connection","sendConnection","id","onAccountChange","publicKey","removeAccountChangeListener","onSlotChange","removeSlotChangeListener","useConnection","context","Error","useSendConnection","useConnectionConfig","endpointInfo","find","info","useAccountInfo","cacheKey","toBase58","accountInfo","loaded","getAccountInfo","refreshInterval","has","currentItem","get","count","previousInfo","subscriptionId","data","equals","lamports","set","nextCount","delete","previousInfoRef","current","useAccountData"],"mappings":";AAAA,SAASA,oBAAT,QAAqC,SAArC;AACA,SAASC,OAAT,EAA+BC,UAA/B,QAA4D,iBAA5D;AACA,OAAOC,KAAP,IAAgBC,UAAhB,EAA4BC,SAA5B,EAAuCC,OAAvC,EAAgDC,MAAhD,QAA8D,OAA9D;AACA,SAASC,QAAT,EAAmBC,YAAnB,QAAuC,cAAvC;AACA,OAAOC,KAAP,MAAkB,iBAAlB;AAGA,OAAO,MAAMC,SAAyB,GAAG,CACvC;AACEC,EAAAA,IAAI,EAAE,cADR;AAEEC,EAAAA,QAAQ,EAAE,qCAFZ;AAGEC,EAAAA,MAAM,EAAE;AAHV,CADuC,EAMvC;AAAEF,EAAAA,IAAI,EAAE,UAAR;AAAoBC,EAAAA,QAAQ,EAAE,uBAA9B;AAAuDC,EAAAA,MAAM,EAAE;AAA/D,CANuC,CAAlC;AASP,MAAMC,oBAAoB,GAAG,IAAIC,GAAJ,EAA7B;AAEA,MAAMC,iBAAgE,GAAGd,KAAK,CAACe,aAAN,CACvE,IADuE,CAAzE;AAIA,OAAO,SAASC,kBAAT,CAA4B;AAAEC,EAAAA;AAAF,CAA5B,EAA0C;AAC/C,QAAM,CAACP,QAAD,EAAWQ,WAAX,IAA0BrB,oBAAoB,CAClD,kBADkD,EAElDW,SAAS,CAAC,CAAD,CAAT,CAAaE,QAFqC,CAApD;AAIA,QAAM,CAACS,eAAD,EAAkBC,kBAAlB,IAAwCvB,oBAAoB,CAEhE,2BAFgE,EAEnC,EAFmC,CAAlE;AAGA,QAAMwB,kBAAkB,GAAGb,SAAS,CAACc,MAAV,CAAiBH,eAAjB,CAA3B;AAEA,QAAMI,UAAU,GAAGpB,OAAO,CAAC,MAAM,IAAIJ,UAAJ,CAAeW,QAAf,EAAyB,QAAzB,CAAP,EAA2C,CACnEA,QADmE,CAA3C,CAA1B;AAGA,QAAMc,cAAc,GAAGrB,OAAO,CAAC,MAAM,IAAIJ,UAAJ,CAAeW,QAAf,EAAyB,QAAzB,CAAP,EAA2C,CACvEA,QADuE,CAA3C,CAA9B,CAb+C,CAiB/C;AACA;AACA;;AACAR,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMuB,EAAE,GAAGF,UAAU,CAACG,eAAX,CAA2B,IAAI5B,OAAJ,GAAc6B,SAAzC,EAAoD,MAAM,CAAE,CAA5D,CAAX;AACA,WAAO,MAAM;AACXJ,MAAAA,UAAU,CAACK,2BAAX,CAAuCH,EAAvC;AACD,KAFD;AAGD,GALQ,EAKN,CAACF,UAAD,CALM,CAAT;AAOArB,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMuB,EAAE,GAAGF,UAAU,CAACM,YAAX,CAAwB,MAAM,IAA9B,CAAX;AACA,WAAO,MAAM;AACXN,MAAAA,UAAU,CAACO,wBAAX,CAAoCL,EAApC;AACD,KAFD;AAGD,GALQ,EAKN,CAACF,UAAD,CALM,CAAT;AAOArB,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMuB,EAAE,GAAGD,cAAc,CAACE,eAAf,CACT,IAAI5B,OAAJ,GAAc6B,SADL,EAET,MAAM,CAAE,CAFC,CAAX;AAIA,WAAO,MAAM;AACXH,MAAAA,cAAc,CAACI,2BAAf,CAA2CH,EAA3C;AACD,KAFD;AAGD,GARQ,EAQN,CAACD,cAAD,CARM,CAAT;AAUAtB,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMuB,EAAE,GAAGD,cAAc,CAACK,YAAf,CAA4B,MAAM,IAAlC,CAAX;AACA,WAAO,MAAM;AACXL,MAAAA,cAAc,CAACM,wBAAf,CAAwCL,EAAxC;AACD,KAFD;AAGD,GALQ,EAKN,CAACD,cAAD,CALM,CAAT;AAOA,sBACE,oBAAC,iBAAD,CAAmB,QAAnB;AACE,IAAA,KAAK,EAAE;AACLd,MAAAA,QADK;AAELQ,MAAAA,WAFK;AAGLK,MAAAA,UAHK;AAILC,MAAAA,cAJK;AAKLH,MAAAA,kBALK;AAMLD,MAAAA;AANK,KADT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAUGH,QAVH,CADF;AAcD;AAED,OAAO,SAASc,aAAT,GAAyB;AAC9B,QAAMC,OAAO,GAAG/B,UAAU,CAACa,iBAAD,CAA1B;;AACA,MAAI,CAACkB,OAAL,EAAc;AACZ,UAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,SAAOD,OAAO,CAACT,UAAf;AACD;AAED,OAAO,SAASW,iBAAT,GAA6B;AAClC,QAAMF,OAAO,GAAG/B,UAAU,CAACa,iBAAD,CAA1B;;AACA,MAAI,CAACkB,OAAL,EAAc;AACZ,UAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,SAAOD,OAAO,CAACR,cAAf;AACD;AAED,OAAO,SAASW,mBAAT,GAA+B;AACpC,QAAMH,OAAO,GAAG/B,UAAU,CAACa,iBAAD,CAA1B;;AACA,MAAI,CAACkB,OAAL,EAAc;AACZ,UAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,SAAO;AACLvB,IAAAA,QAAQ,EAAEsB,OAAO,CAACtB,QADb;AAEL0B,IAAAA,YAAY,EAAEJ,OAAO,CAACX,kBAAR,CAA2BgB,IAA3B,CACXC,IAAD,IAAUA,IAAI,CAAC5B,QAAL,KAAkBsB,OAAO,CAACtB,QADxB,CAFT;AAKLQ,IAAAA,WAAW,EAAEc,OAAO,CAACd,WALhB;AAMLG,IAAAA,kBAAkB,EAAEW,OAAO,CAACX,kBANvB;AAOLD,IAAAA,kBAAkB,EAAEY,OAAO,CAACZ;AAPvB,GAAP;AASD;AAED,OAAO,SAASmB,cAAT,CACLZ,SADK,EAE8C;AACnD,QAAMJ,UAAU,GAAGQ,aAAa,EAAhC;AACA,QAAMS,QAAQ,GAAGjC,KAAK,CAACgB,UAAD,EAAaI,SAAb,aAAaA,SAAb,uBAAaA,SAAS,CAAEc,QAAX,EAAb,CAAtB;AACA,QAAM,CAACC,WAAD,EAAcC,MAAd,IAAwBrC,YAAY,CACxC,YAAaqB,SAAS,GAAGJ,UAAU,CAACqB,cAAX,CAA0BjB,SAA1B,CAAH,GAA0C,IADxB,EAExCa,QAFwC,EAGxC;AAAEK,IAAAA,eAAe,EAAE;AAAnB,GAHwC,CAA1C;AAKA3C,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAACyB,SAAL,EAAgB;AACd;AACD;;AACD,QAAIf,oBAAoB,CAACkC,GAArB,CAAyBN,QAAzB,CAAJ,EAAwC;AACtC,UAAIO,WAAW,GAAGnC,oBAAoB,CAACoC,GAArB,CAAyBR,QAAzB,CAAlB;AACA,QAAEO,WAAW,CAACE,KAAd;AACD,KAHD,MAGO;AACL,UAAIC,YAAwC,GAAG,IAA/C;AACA,YAAMC,cAAc,GAAG5B,UAAU,CAACG,eAAX,CAA2BC,SAA3B,EAAuCW,IAAD,IAAU;AACrE,YACE,CAACY,YAAD,IACA,CAACA,YAAY,CAACE,IAAb,CAAkBC,MAAlB,CAAyBf,IAAI,CAACc,IAA9B,CADD,IAEAF,YAAY,CAACI,QAAb,KAA0BhB,IAAI,CAACgB,QAHjC,EAIE;AACAJ,UAAAA,YAAY,GAAGZ,IAAf;AACAjC,UAAAA,QAAQ,CAACmC,QAAD,EAAWF,IAAX,CAAR;AACD;AACF,OATsB,CAAvB;AAUA1B,MAAAA,oBAAoB,CAAC2C,GAArB,CAAyBf,QAAzB,EAAmC;AAAES,QAAAA,KAAK,EAAE,CAAT;AAAYE,QAAAA;AAAZ,OAAnC;AACD;;AACD,WAAO,MAAM;AACX,UAAIJ,WAAW,GAAGnC,oBAAoB,CAACoC,GAArB,CAAyBR,QAAzB,CAAlB;AACA,UAAIgB,SAAS,GAAGT,WAAW,CAACE,KAAZ,GAAoB,CAApC;;AACA,UAAIO,SAAS,IAAI,CAAjB,EAAoB;AAClBjC,QAAAA,UAAU,CAACK,2BAAX,CAAuCmB,WAAW,CAACI,cAAnD;AACAvC,QAAAA,oBAAoB,CAAC6C,MAArB,CAA4BjB,QAA5B;AACD,OAHD,MAGO;AACL,UAAEO,WAAW,CAACE,KAAd;AACD;AACF,KATD,CArBc,CA+Bd;AACD,GAhCQ,EAgCN,CAACT,QAAD,CAhCM,CAAT;AAiCA,QAAMkB,eAAe,GAAGtD,MAAM,CAAyC,IAAzC,CAA9B;;AACA,MACE,CAACsC,WAAD,IACA,CAACgB,eAAe,CAACC,OADjB,IAEA,CAACD,eAAe,CAACC,OAAhB,CAAwBP,IAAxB,CAA6BC,MAA7B,CAAoCX,WAAW,CAACU,IAAhD,CAFD,IAGAM,eAAe,CAACC,OAAhB,CAAwBL,QAAxB,KAAqCZ,WAAW,CAACY,QAJnD,EAKE;AACAI,IAAAA,eAAe,CAACC,OAAhB,GAA0BjB,WAA1B;AACD;;AACD,SAAO,CAACgB,eAAe,CAACC,OAAjB,EAA0BhB,MAA1B,CAAP;AACD;AAED,OAAO,SAASiB,cAAT,CAAwBjC,SAAxB,EAAmC;AACxC,QAAM,CAACe,WAAD,IAAgBH,cAAc,CAACZ,SAAD,CAApC;AACA,SAAOe,WAAW,IAAIA,WAAW,CAACU,IAAlC;AACD","sourcesContent":["import { useLocalStorageState } from './utils';\nimport { Account, AccountInfo, Connection, PublicKey } from '@solana/web3.js';\nimport React, { useContext, useEffect, useMemo, useRef } from 'react';\nimport { setCache, useAsyncData } from './fetch-loop';\nimport tuple from 'immutable-tuple';\nimport { ConnectionContextValues, EndpointInfo } from './types';\n\nexport const ENDPOINTS: EndpointInfo[] = [\n  {\n    name: 'mainnet-beta',\n    endpoint: 'https://solana-api.projectserum.com',\n    custom: false,\n  },\n  { name: 'localnet', endpoint: 'http://127.0.0.1:8899', custom: false },\n];\n\nconst accountListenerCount = new Map();\n\nconst ConnectionContext: React.Context<null | ConnectionContextValues> = React.createContext<null | ConnectionContextValues>(\n  null,\n);\n\nexport function ConnectionProvider({ children }) {\n  const [endpoint, setEndpoint] = useLocalStorageState<string>(\n    'connectionEndpts',\n    ENDPOINTS[0].endpoint,\n  );\n  const [customEndpoints, setCustomEndpoints] = useLocalStorageState<\n    EndpointInfo[]\n  >('customConnectionEndpoints', []);\n  const availableEndpoints = ENDPOINTS.concat(customEndpoints);\n\n  const connection = useMemo(() => new Connection(endpoint, 'recent'), [\n    endpoint,\n  ]);\n  const sendConnection = useMemo(() => new Connection(endpoint, 'recent'), [\n    endpoint,\n  ]);\n\n  // The websocket library solana/web3.js uses closes its websocket connection when the subscription list\n  // is empty after opening its first time, preventing subsequent subscriptions from receiving responses.\n  // This is a hack to prevent the list from every getting empty\n  useEffect(() => {\n    const id = connection.onAccountChange(new Account().publicKey, () => {});\n    return () => {\n      connection.removeAccountChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = connection.onSlotChange(() => null);\n    return () => {\n      connection.removeSlotChangeListener(id);\n    };\n  }, [connection]);\n\n  useEffect(() => {\n    const id = sendConnection.onAccountChange(\n      new Account().publicKey,\n      () => {},\n    );\n    return () => {\n      sendConnection.removeAccountChangeListener(id);\n    };\n  }, [sendConnection]);\n\n  useEffect(() => {\n    const id = sendConnection.onSlotChange(() => null);\n    return () => {\n      sendConnection.removeSlotChangeListener(id);\n    };\n  }, [sendConnection]);\n\n  return (\n    <ConnectionContext.Provider\n      value={{\n        endpoint,\n        setEndpoint,\n        connection,\n        sendConnection,\n        availableEndpoints,\n        setCustomEndpoints,\n      }}\n    >\n      {children}\n    </ConnectionContext.Provider>\n  );\n}\n\nexport function useConnection() {\n  const context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  return context.connection;\n}\n\nexport function useSendConnection() {\n  const context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  return context.sendConnection;\n}\n\nexport function useConnectionConfig() {\n  const context = useContext(ConnectionContext);\n  if (!context) {\n    throw new Error('Missing connection context');\n  }\n  return {\n    endpoint: context.endpoint,\n    endpointInfo: context.availableEndpoints.find(\n      (info) => info.endpoint === context.endpoint,\n    ),\n    setEndpoint: context.setEndpoint,\n    availableEndpoints: context.availableEndpoints,\n    setCustomEndpoints: context.setCustomEndpoints,\n  };\n}\n\nexport function useAccountInfo(\n  publicKey: PublicKey | undefined | null,\n): [AccountInfo<Buffer> | null | undefined, boolean] {\n  const connection = useConnection();\n  const cacheKey = tuple(connection, publicKey?.toBase58());\n  const [accountInfo, loaded] = useAsyncData<AccountInfo<Buffer> | null>(\n    async () => (publicKey ? connection.getAccountInfo(publicKey) : null),\n    cacheKey,\n    { refreshInterval: 60_000 },\n  );\n  useEffect(() => {\n    if (!publicKey) {\n      return;\n    }\n    if (accountListenerCount.has(cacheKey)) {\n      let currentItem = accountListenerCount.get(cacheKey);\n      ++currentItem.count;\n    } else {\n      let previousInfo: AccountInfo<Buffer> | null = null;\n      const subscriptionId = connection.onAccountChange(publicKey, (info) => {\n        if (\n          !previousInfo ||\n          !previousInfo.data.equals(info.data) ||\n          previousInfo.lamports !== info.lamports\n        ) {\n          previousInfo = info;\n          setCache(cacheKey, info);\n        }\n      });\n      accountListenerCount.set(cacheKey, { count: 1, subscriptionId });\n    }\n    return () => {\n      let currentItem = accountListenerCount.get(cacheKey);\n      let nextCount = currentItem.count - 1;\n      if (nextCount <= 0) {\n        connection.removeAccountChangeListener(currentItem.subscriptionId);\n        accountListenerCount.delete(cacheKey);\n      } else {\n        --currentItem.count;\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheKey]);\n  const previousInfoRef = useRef<AccountInfo<Buffer> | null | undefined>(null);\n  if (\n    !accountInfo ||\n    !previousInfoRef.current ||\n    !previousInfoRef.current.data.equals(accountInfo.data) ||\n    previousInfoRef.current.lamports !== accountInfo.lamports\n  ) {\n    previousInfoRef.current = accountInfo;\n  }\n  return [previousInfoRef.current, loaded];\n}\n\nexport function useAccountData(publicKey) {\n  const [accountInfo] = useAccountInfo(publicKey);\n  return accountInfo && accountInfo.data;\n}\n"]},"metadata":{},"sourceType":"module"}