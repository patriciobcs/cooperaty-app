"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolTransactions = void 0;
const instructions_1 = require("./instructions");
const web3_js_1 = require("@solana/web3.js");
const serum_1 = require("@project-serum/serum");
const bn_js_1 = __importDefault(require("bn.js"));
const associated_token_1 = require("@project-serum/associated-token");
/**
 * High-level API for constructing transactions to interact with pools.
 *
 * For a lower-level API, see {@link PoolInstructions}.
 */
class PoolTransactions {
    /**
     * Transaction to initialize a simple pool.
     *
     * This will:
     * - initialize a new pool token mint
     * - initialize a pool token account for the creator and mint some tokens to it
     * - initialize vault accounts for each of the pool assets
     * - transfer assets from the pool creator to the vault accounts
     * - initialize the pool
     */
    static async initializeSimplePool(params) {
        const { connection, programId, poolStateSpace, poolMintDecimals = 6, poolName, assetMints, initialPoolMintSupply = new bn_js_1.default('1' + '0'.repeat(poolMintDecimals)), initialAssetQuantities, creator, creatorAssets, feeRate = 2500, additionalAccounts = [], } = params;
        if (assetMints.length !== initialAssetQuantities.length) {
            throw new Error('assetMints and initialAssetQuantities must have the same length');
        }
        if (assetMints.length !== creatorAssets.length) {
            throw new Error('assetMints and creatorAssets must have the same length');
        }
        const poolStateAccount = new web3_js_1.Account();
        const [vaultSigner, vaultSignerNonce] = await web3_js_1.PublicKey.findProgramAddress([poolStateAccount.publicKey.toBuffer()], programId);
        const poolTokenMint = new web3_js_1.Account();
        const creatorPoolTokenAddress = await associated_token_1.getAssociatedTokenAddress(creator, poolTokenMint.publicKey);
        const vaultAddresses = await Promise.all(assetMints.map(mint => associated_token_1.getAssociatedTokenAddress(vaultSigner, mint)));
        const lqdFeeAddress = await associated_token_1.getAssociatedTokenAddress(instructions_1.LQD_FEE_OWNER_ADDRESS, poolTokenMint.publicKey);
        // Split into two transactions to stay under the size limit.
        // Ideally all instructions that transfer tokens happen in the second transaction,
        // so they get reverted if the pool creation fails.
        const setup = {
            transaction: new web3_js_1.Transaction(),
            signers: [poolTokenMint],
        };
        const finalize = {
            transaction: new web3_js_1.Transaction(),
            signers: [poolStateAccount],
        };
        const mintAccountSpace = 82;
        const mintAccountLamports = await connection.getMinimumBalanceForRentExemption(mintAccountSpace);
        // Initialize pool token.
        setup.transaction.add(web3_js_1.SystemProgram.createAccount({
            fromPubkey: creator,
            newAccountPubkey: poolTokenMint.publicKey,
            space: mintAccountSpace,
            lamports: mintAccountLamports,
            programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,
        }), serum_1.TokenInstructions.initializeMint({
            mint: poolTokenMint.publicKey,
            decimals: poolMintDecimals,
            mintAuthority: creator,
        }), await associated_token_1.createAssociatedTokenAccount(creator, creator, poolTokenMint.publicKey), await associated_token_1.createAssociatedTokenAccount(creator, instructions_1.LQD_FEE_OWNER_ADDRESS, poolTokenMint.publicKey));
        finalize.transaction.add(serum_1.TokenInstructions.mintTo({
            mint: poolTokenMint.publicKey,
            destination: creatorPoolTokenAddress,
            amount: initialPoolMintSupply,
            mintAuthority: creator,
        }), serum_1.TokenInstructions.setAuthority({
            target: poolTokenMint.publicKey,
            currentAuthority: creator,
            newAuthority: vaultSigner,
            authorityType: 0,
        }));
        // Initialize vault accounts.
        await Promise.all(assetMints.map(async (mint, index) => {
            const vault = vaultAddresses[index];
            setup.transaction.add(await associated_token_1.createAssociatedTokenAccount(creator, vaultSigner, mint));
            finalize.transaction.add(serum_1.TokenInstructions.transfer({
                source: creatorAssets[index],
                destination: vault,
                amount: initialAssetQuantities[index],
                owner: creator,
            }));
        }));
        // Initialize pool account.
        finalize.transaction.add(web3_js_1.SystemProgram.createAccount({
            fromPubkey: creator,
            newAccountPubkey: poolStateAccount.publicKey,
            space: poolStateSpace,
            lamports: await connection.getMinimumBalanceForRentExemption(poolStateSpace),
            programId: programId,
        }), instructions_1.PoolInstructions.initialize(programId, poolStateAccount.publicKey, poolTokenMint.publicKey, poolName, vaultAddresses, vaultSigner, vaultSignerNonce, lqdFeeAddress, creatorPoolTokenAddress, feeRate, additionalAccounts));
        return [poolStateAccount.publicKey, [setup, finalize]];
    }
    /**
     * Transaction to get a pool basket, for use with simulateTransaction.
     *
     * This is a wrapper around {@link PoolInstructions.getBasket} that handles
     * initializing the retbuf account.
     *
     * @param pool Pool to interact with.
     * @param action Creation, redemption, or swap.
     * @param payer Payer for fees. Must have nonzero SOL but will not be charged
     * if the transaction is only simulated.
     */
    static getBasket(pool, action, payer) {
        const transaction = new web3_js_1.Transaction();
        const retbufAccount = new web3_js_1.Account();
        transaction.add(web3_js_1.SystemProgram.createAccount({
            fromPubkey: payer,
            newAccountPubkey: retbufAccount.publicKey,
            lamports: 0,
            space: 1024,
            programId: instructions_1.RETBUF_PROGRAM_ID,
        }));
        transaction.add(instructions_1.PoolInstructions.getBasket(pool, action, retbufAccount.publicKey));
        transaction.feePayer = payer;
        return { transaction, signers: [retbufAccount] };
    }
    /**
     * Transaction to execute a creation, redemption, or swap.
     *
     * This is a wrapper around {@link PoolInstructions.execute} that handles
     * token delegation.
     *
     * The transaction will create a temporary account, delegate tokens to it,
     * and use it in place of the actual owner, to limit the quantity of tokens
     * that the pool can pull from the user's accounts.
     *
     * @param pool Pool to interact with.
     * @param action Creation, redemption, or swap.
     * @param user Token accounts to pull funds from or send funds to.
     * @param expectedBasket Expected basket. Used to determine the quantity of
     * tokens to approve.
     */
    static execute(pool, action, user, expectedBasket) {
        if (expectedBasket.quantities.length !== pool.state.assets.length) {
            throw new Error('expectedBasket must have the same number of components as the pool');
        }
        const transaction = new web3_js_1.Transaction();
        const delegate = new web3_js_1.Account();
        const signers = [delegate];
        user = { ...user, assetAccounts: user.assetAccounts.slice() };
        let wrappedSolAccount = null;
        function approveDelegate(amount, index, approveZero = false) {
            if (user.assetAccounts[index].equals(user.owner) &&
                pool.state.assets[index].mint.equals(serum_1.TokenInstructions.WRAPPED_SOL_MINT)) {
                wrappedSolAccount = new web3_js_1.Account();
                signers.push(wrappedSolAccount);
                transaction.add(web3_js_1.SystemProgram.createAccount({
                    fromPubkey: user.owner,
                    newAccountPubkey: wrappedSolAccount.publicKey,
                    lamports: amount.toNumber() + 2.04e6,
                    space: 165,
                    programId: serum_1.TokenInstructions.TOKEN_PROGRAM_ID,
                }), serum_1.TokenInstructions.initializeAccount({
                    account: wrappedSolAccount.publicKey,
                    mint: serum_1.TokenInstructions.WRAPPED_SOL_MINT,
                    owner: delegate.publicKey,
                }));
                user.assetAccounts[index] = wrappedSolAccount.publicKey;
            }
            else if (amount.gtn(0) || approveZero) {
                transaction.add(serum_1.TokenInstructions.approve({
                    owner: user.owner,
                    source: user.assetAccounts[index],
                    delegate: delegate.publicKey,
                    amount,
                }));
            }
        }
        if ('create' in action) {
            expectedBasket.quantities.forEach((amount, index) => {
                approveDelegate(amount, index, true);
            });
        }
        else if ('redeem' in action) {
            transaction.add(serum_1.TokenInstructions.approve({
                owner: user.owner,
                source: user.poolTokenAccount,
                delegate: delegate.publicKey,
                amount: action.redeem,
            }));
            expectedBasket.quantities.forEach((amount, index) => {
                if (amount.isNeg()) {
                    approveDelegate(amount.abs(), index);
                }
                else {
                    approveDelegate(new bn_js_1.default(0), index);
                }
            });
        }
        else if ('swap' in action) {
            action.swap.quantities.forEach((amount, index) => {
                approveDelegate(amount, index);
            });
        }
        transaction.add(instructions_1.PoolInstructions.execute(pool, action, {
            ...user,
            owner: delegate.publicKey,
        }));
        if (wrappedSolAccount) {
            transaction.add(serum_1.TokenInstructions.closeAccount({
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                source: wrappedSolAccount.publicKey,
                destination: user.owner,
                owner: delegate.publicKey,
            }));
        }
        return { transaction, signers };
    }
}
exports.PoolTransactions = PoolTransactions;
//# sourceMappingURL=transactions.js.map